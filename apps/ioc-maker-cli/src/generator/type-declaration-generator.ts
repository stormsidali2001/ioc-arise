import { ClassInfo } from '../types';
import { relative, dirname } from 'path';
import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'fs';
import { glob } from 'glob';

export class TypeDeclarationGenerator {
    static generate(classes: ClassInfo[], outputPath: string): void {
        // outputPath already has .d.ts extension from the generator
        const typeDeclarations = this.generateTypeDeclarations(classes, outputPath);
        mkdirSync(dirname(outputPath), { recursive: true });
        writeFileSync(outputPath, typeDeclarations);
    }

    private static generateTypeDeclarations(classes: ClassInfo[], outputPath: string): string {
        // Filter classes that have interface implementations or abstract class implementations
        const interfaceClasses = classes.filter(cls => cls.interfaceName);
        const abstractClasses = classes.filter(cls => cls.abstractClassName);

        if (interfaceClasses.length === 0 && abstractClasses.length === 0) {
            // No interfaces or abstract classes, generate minimal type file
            return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 */

export interface ContainerRegistry {}
`;
        }

        const typeImports = this.generateTypeImports(interfaceClasses, abstractClasses, outputPath);

        // Build registry entries for both interfaces and abstract classes
        const registryEntries: string[] = [];

        interfaceClasses.forEach(cls => {
            registryEntries.push(`  '${cls.interfaceName}': ${cls.interfaceName};`);
        });

        abstractClasses.forEach(cls => {
            // For abstract classes, we use the concrete implementation type
            registryEntries.push(`  '${cls.abstractClassName}': ${cls.name};`);
        });

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 * 
 * This file provides type-safe resolution for string-based tokens.
 */
${typeImports}

export interface ContainerRegistry {
${registryEntries.join('\n')}
}
`;
    }

    private static generateTypeImports(interfaceClasses: ClassInfo[], abstractClasses: ClassInfo[], outputPath: string): string {
        const outputDir = dirname(outputPath);
        const imports: string[] = [];

        // Build a map of interface names to their actual file paths by searching the source
        const interfaceLocations = this.findInterfaceLocations(interfaceClasses, outputDir);

        interfaceClasses.forEach(cls => {
            if (!cls.interfaceName) return;

            const relativePath = interfaceLocations.get(cls.interfaceName);
            if (relativePath) {
                imports.push(`import type { ${cls.interfaceName} } from '${relativePath}';`);
            }
        });

        // For abstract classes, import the concrete implementation class
        abstractClasses.forEach(cls => {
            let relativePath = relative(outputDir, cls.filePath);
            relativePath = relativePath.replace(/\.ts$/, '');
            if (!relativePath.startsWith('.')) {
                relativePath = `./${relativePath}`;
            }
            relativePath = relativePath.replace(/\\/g, '/');

            imports.push(`import type { ${cls.name} } from '${relativePath}';`);
        });

        return imports.join('\n');
    }

    private static findInterfaceLocations(classes: ClassInfo[], outputDir: string): Map<string, string> {
        const interfaceLocations = new Map<string, string>();
        const interfaceNames = new Set(classes.filter(c => c.interfaceName).map(c => c.interfaceName!));

        if (interfaceNames.size === 0) return interfaceLocations;

        // For each class with an interface, parse its file to find the actual interface import
        classes.forEach(cls => {
            if (!cls.interfaceName || interfaceLocations.has(cls.interfaceName)) return;

            try {
                const fileContent = readFileSync(cls.filePath, 'utf-8');
                // Match: import { InterfaceName } from './path';
                // or: import type { InterfaceName } from './path';
                const importRegex = new RegExp(
                    `import\\s+(?:type\\s+)?\\{[^}]*\\b${cls.interfaceName}\\b[^}]*\\}\\s+from\\s+['"]([^'"]+)['"]`,
                    'g'
                );

                const match = importRegex.exec(fileContent);
                if (match && match[1]) {
                    // Found the import path relative to the class file
                    const classDir = dirname(cls.filePath);
                    const interfacePathFromClass = match[1];

                    // Resolve the absolute path of the interface file
                    const interfaceAbsPath = require('path').resolve(classDir, interfacePathFromClass);

                    // Calculate relative path from output directory
                    let relativePath = relative(outputDir, interfaceAbsPath);

                    // Normalize
                    if (!relativePath.startsWith('.')) {
                        relativePath = `./${relativePath}`;
                    }
                    relativePath = relativePath.replace(/\\/g, '/');

                    interfaceLocations.set(cls.interfaceName, relativePath);
                }
            } catch (error) {
                // If we can't read the file or parse it, skip
                const { Logger } = require('../utils/logger');
                Logger.debug(`Could not parse interface location for ${cls.interfaceName} in ${cls.filePath}`);
            }
        });

        return interfaceLocations;
    }

    private static generateRegistryInterface(classes: ClassInfo[]): string {
        const registrations = classes
            .filter(cls => cls.interfaceName)
            .map(cls => `  '${cls.interfaceName}': ${cls.interfaceName};`)
            .join('\n');

        return `export interface ContainerRegistry {
${registrations}
}`;
    }

    private static generateModuleAugmentation(): string {
        return `declare module '@notjustcoders/di-container' {
  interface Container {
    /**
     * Type-safe resolve for registered string tokens.
     * Returns the correctly typed instance based on the token.
     */
    resolve<K extends keyof ContainerRegistry>(token: K): ContainerRegistry[K];
    
    /**
     * Generic resolve for class constructors or other token types.
     */
    resolve<T>(token: import('@notjustcoders/di-container').Token<T>): T;
  }
}`;
    }
}

