import { ClassInfo, FactoryInfo, ValueInfo } from '../types';
import { relative, dirname, join } from 'path';
import { writeFileSync, mkdirSync, readFileSync, existsSync } from 'fs';
import { glob } from 'glob';
import { ErrorFactory } from '../errors/errorFactory';

export class TypeDeclarationGenerator {
    static generate(classes: ClassInfo[], outputPath: string, factories?: FactoryInfo[], values?: ValueInfo[]): void {
        // Check for name collisions before generating
        this.checkForNameCollisions(classes);

        // outputPath already has .d.ts extension from the generator
        const typeDeclarations = this.generateTypeDeclarations(classes, outputPath, factories, values);
        mkdirSync(dirname(outputPath), { recursive: true });
        writeFileSync(outputPath, typeDeclarations);
    }

    private static generateTypeDeclarations(classes: ClassInfo[], outputPath: string, factories?: FactoryInfo[], values?: ValueInfo[]): string {
        // Filter classes that have interface implementations or abstract class implementations
        const interfaceClasses = classes.filter(cls => cls.interfaceName);
        const abstractClasses = classes.filter(cls => cls.abstractClassName);
        // Classes without interfaces or abstract classes (direct class registrations)
        const directClasses = classes.filter(cls => !cls.interfaceName && !cls.abstractClassName);

        if (interfaceClasses.length === 0 && abstractClasses.length === 0 && directClasses.length === 0) {
            // No classes at all, generate minimal type file
            return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 */

export interface ContainerRegistry {}
`;
        }

        const typeImports = this.generateTypeImports(interfaceClasses, abstractClasses, directClasses, outputPath, factories, values);

        // Build registry entries for interfaces, abstract classes, direct classes, and factories
        const registryEntries: string[] = [];

        interfaceClasses.forEach(cls => {
            registryEntries.push(`  '${cls.interfaceName}': ${cls.interfaceName};`);
        });

        abstractClasses.forEach(cls => {
            // For abstract classes, we use the concrete implementation type
            registryEntries.push(`  '${cls.abstractClassName}': ${cls.name};`);
        });

        // For direct classes, use the class name as the token and the class type
        directClasses.forEach(cls => {
            registryEntries.push(`  '${cls.name}': ${cls.name};`);
        });

        // For factories, use the function name as the token
        if (factories) {
            factories.forEach(factory => {
                const token = factory.token || factory.name;
                // Use ReturnType<typeof factoryName> as the type
                registryEntries.push(`  '${token}': ReturnType<typeof ${factory.name}>;`);
            });
        }

        // For values, use the interface name or value name as the token
        if (values) {
            values.forEach(value => {
                const token = value.token || value.interfaceName || value.name;
                // Use the interface type if available, otherwise use typeof valueName
                const type = value.interfaceName || `typeof ${value.name}`;
                registryEntries.push(`  '${token}': ${type};`);
            });
        }

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 * 
 * This file provides type-safe resolution for string-based tokens.
 */
${typeImports}

export interface ContainerRegistry {
${registryEntries.join('\n')}
}
`;
    }

    private static generateTypeImports(
        interfaceClasses: ClassInfo[],
        abstractClasses: ClassInfo[],
        directClasses: ClassInfo[],
        outputPath: string,
        factories?: FactoryInfo[],
        values?: ValueInfo[]
    ): string {
        const outputDir = dirname(outputPath);
        const imports: string[] = [];

        // Build a map of interface names to their actual file paths by searching the source
        const interfaceLocations = this.findInterfaceLocations(interfaceClasses, outputDir);

        interfaceClasses.forEach(cls => {
            if (!cls.interfaceName) return;

            const relativePath = interfaceLocations.get(cls.interfaceName);
            if (relativePath) {
                imports.push(`import type { ${cls.interfaceName} } from '${relativePath}';`);
            }
        });

        // For abstract classes, import the concrete implementation class
        abstractClasses.forEach(cls => {
            let relativePath = relative(outputDir, cls.filePath);
            relativePath = relativePath.replace(/\.ts$/, '');
            if (!relativePath.startsWith('.')) {
                relativePath = `./${relativePath}`;
            }
            relativePath = relativePath.replace(/\\/g, '/');

            imports.push(`import type { ${cls.name} } from '${relativePath}';`);
        });

        // For direct classes, import without aliases
        directClasses.forEach(cls => {
            let relativePath = relative(outputDir, cls.filePath);
            relativePath = relativePath.replace(/\.ts$/, '');
            if (!relativePath.startsWith('.')) {
                relativePath = `./${relativePath}`;
            }
            relativePath = relativePath.replace(/\\/g, '/');

            imports.push(`import type { ${cls.name} } from '${relativePath}';`);
        });

        // Import factory functions for ReturnType
        if (factories) {
            factories.forEach(factory => {
                let relativePath = relative(outputDir, factory.filePath);
                relativePath = relativePath.replace(/\.ts$/, '');
                if (!relativePath.startsWith('.')) {
                    relativePath = `./${relativePath}`;
                }
                relativePath = relativePath.replace(/\\/g, '/');
                imports.push(`import { ${factory.name} } from '${relativePath}';`);
            });
        }

        // Import interface types for values (we don't need to import the values themselves in .d.ts)
        if (values) {
            values.forEach(value => {
                // Only import the interface type, not the value itself
                if (value.interfaceName) {
                    // Find interface location by checking imports in the value file
                    const interfacePath = this.findInterfaceLocationForValue(value, outputDir);
                    if (interfacePath) {
                        imports.push(`import type { ${value.interfaceName} } from '${interfacePath}';`);
                    }
                }
            });
        }

        return imports.join('\n');
    }

    private static findInterfaceLocationForValue(value: ValueInfo, outputDir: string): string | null {
        try {
            // Read the value file to find where the interface is imported from
            const fileContent = readFileSync(value.filePath, 'utf-8');

            // Match: import { InterfaceName } from './path';
            // or: import type { InterfaceName } from './path';
            const importRegex = new RegExp(
                `import\\s+(?:type\\s+)?\\{[^}]*\\b${value.interfaceName}\\b[^}]*\\}\\s+from\\s+['"]([^'"]+)['"]`,
                'g'
            );

            const match = importRegex.exec(fileContent);
            if (match && match[1]) {
                // Found the import path relative to the value file
                const valueDir = dirname(value.filePath);
                const interfacePathFromValue = match[1];

                // Resolve the absolute path of the interface file
                const absoluteInterfacePath = join(valueDir, interfacePathFromValue);
                const normalizedInterfacePath = absoluteInterfacePath.endsWith('.ts')
                    ? absoluteInterfacePath
                    : absoluteInterfacePath + '.ts';

                // Check if the file exists
                if (existsSync(normalizedInterfacePath)) {
                    // Convert to relative path from output directory
                    let relativePath = relative(outputDir, normalizedInterfacePath);
                    relativePath = relativePath.replace(/\.ts$/, '');
                    if (!relativePath.startsWith('.')) {
                        relativePath = `./${relativePath}`;
                    }
                    return relativePath.replace(/\\/g, '/');
                }
            }

            // Fallback: assume interface is in a file named I{InterfaceName}.ts in the same directory
            const valueDir = dirname(value.filePath);
            const interfaceFileName = value.interfaceName + '.ts';
            const interfacePath = join(valueDir, interfaceFileName);

            if (existsSync(interfacePath)) {
                let relativePath = relative(outputDir, interfacePath);
                relativePath = relativePath.replace(/\.ts$/, '');
                if (!relativePath.startsWith('.')) {
                    relativePath = `./${relativePath}`;
                }
                return relativePath.replace(/\\/g, '/');
            }

            return null;
        } catch (error) {
            return null;
        }
    }

    private static findInterfaceLocations(classes: ClassInfo[], outputDir: string): Map<string, string> {
        const interfaceLocations = new Map<string, string>();
        const interfaceNames = new Set(classes.filter(c => c.interfaceName).map(c => c.interfaceName!));

        if (interfaceNames.size === 0) return interfaceLocations;

        // For each class with an interface, parse its file to find the actual interface import
        classes.forEach(cls => {
            if (!cls.interfaceName || interfaceLocations.has(cls.interfaceName)) return;

            try {
                const fileContent = readFileSync(cls.filePath, 'utf-8');
                // Match: import { InterfaceName } from './path';
                // or: import type { InterfaceName } from './path';
                const importRegex = new RegExp(
                    `import\\s+(?:type\\s+)?\\{[^}]*\\b${cls.interfaceName}\\b[^}]*\\}\\s+from\\s+['"]([^'"]+)['"]`,
                    'g'
                );

                const match = importRegex.exec(fileContent);
                if (match && match[1]) {
                    // Found the import path relative to the class file
                    const classDir = dirname(cls.filePath);
                    const interfacePathFromClass = match[1];

                    // Resolve the absolute path of the interface file
                    const interfaceAbsPath = require('path').resolve(classDir, interfacePathFromClass);

                    // Calculate relative path from output directory
                    let relativePath = relative(outputDir, interfaceAbsPath);

                    // Normalize
                    if (!relativePath.startsWith('.')) {
                        relativePath = `./${relativePath}`;
                    }
                    relativePath = relativePath.replace(/\\/g, '/');

                    interfaceLocations.set(cls.interfaceName, relativePath);
                }
            } catch (error) {
                // If we can't read the file or parse it, skip
                const { Logger } = require('../utils/logger');
                Logger.debug(`Could not parse interface location for ${cls.interfaceName} in ${cls.filePath}`);
            }
        });

        return interfaceLocations;
    }

    private static generateRegistryInterface(classes: ClassInfo[]): string {
        const registrations = classes
            .filter(cls => cls.interfaceName)
            .map(cls => `  '${cls.interfaceName}': ${cls.interfaceName};`)
            .join('\n');

        return `export interface ContainerRegistry {
${registrations}
}`;
    }

    /**
     * Checks for class name collisions and throws an error if any are found
     */
    private static checkForNameCollisions(classes: ClassInfo[]): void {
        const nameToClasses = new Map<string, ClassInfo[]>();

        classes.forEach(cls => {
            if (!nameToClasses.has(cls.name)) {
                nameToClasses.set(cls.name, []);
            }
            nameToClasses.get(cls.name)!.push(cls);
        });

        // Check for collisions
        for (const [className, classesWithSameName] of nameToClasses.entries()) {
            if (classesWithSameName.length > 1) {
                const filePaths = classesWithSameName.map(cls => cls.filePath);
                throw ErrorFactory.classNameCollision(className, filePaths);
            }
        }
    }

    private static generateModuleAugmentation(): string {
        return `declare module '@notjustcoders/di-container' {
  interface Container {
    /**
     * Type-safe resolve for registered string tokens.
     * Returns the correctly typed instance based on the token.
     */
    resolve<K extends keyof ContainerRegistry>(token: K): ContainerRegistry[K];
    
    /**
     * Generic resolve for class constructors or other token types.
     */
    resolve<T>(token: import('@notjustcoders/di-container').Token<T>): T;
  }
}`;
    }
}

