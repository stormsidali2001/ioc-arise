import { ClassInfo } from '../types';
import { relative, dirname, join, basename } from 'path';
import { writeFileSync, mkdirSync } from 'fs';
import { TypeDeclarationGenerator } from './type-declaration-generator';
import { ErrorFactory } from '../errors/errorFactory';

export class IoCContainerGenerator {
    /**
     * Generates the IoC container code for the given classes
     * @param classes - Analyzed classes to be registered (can be flat or grouped)
     * @param outputPath - Path where the container file will be generated
     * @param moduleGroupedClasses - Optional: Classes grouped by modules
     */
    static generate(
        classes: ClassInfo[],
        outputPath: string,
        moduleGroupedClasses?: Map<string, ClassInfo[]>
    ): void {
        // Check for name collisions before generating
        // If moduleGroupedClasses is provided, check all classes from all modules
        const allClassesToCheck = moduleGroupedClasses && moduleGroupedClasses.size > 1
            ? Array.from(moduleGroupedClasses.values()).flat()
            : classes;
        this.checkForNameCollisions(allClassesToCheck);

        // Ensure directory exists
        const outputDir = dirname(outputPath);
        mkdirSync(outputDir, { recursive: true });

        if (moduleGroupedClasses && moduleGroupedClasses.size > 1) {
            // Generate modular code with separate files for each module
            this.generateModularFiles(moduleGroupedClasses, outputPath);
        } else {
            // Generate single flat file
            const containerCode = this.generateFlatCode(classes, outputPath);
            writeFileSync(outputPath, containerCode);
        }

        // Generate type declarations (.d.ts file)
        const typesPath = outputPath.endsWith('.gen.ts')
            ? outputPath.replace(/\.gen\.ts$/, '.gen.d.ts')
            : outputPath.replace(/\.ts$/, '.d.ts');
        TypeDeclarationGenerator.generate(classes, typesPath);
    }

    private static generateFlatCode(classes: ClassInfo[], outputPath: string): string {
        // Collect all interface names to identify which dependencies should use string tokens
        const interfaceNames = new Set<string>();
        classes.forEach(cls => {
            if (cls.interfaceName) {
                interfaceNames.add(cls.interfaceName);
            }
        });

        // Collect abstract class names from dependencies
        const abstractClassNames = new Set<string>();
        classes.forEach(cls => {
            cls.dependencies.forEach(dep => {
                const isInCurrentClasses = classes.some(c => c.name === dep.name);
                const looksLikeAbstractClass = dep.name.startsWith('Abstract') || dep.name.includes('Abstract');
                if (!isInCurrentClasses && looksLikeAbstractClass) {
                    abstractClassNames.add(dep.name);
                }
            });
        });

        const imports = this.generateImports(classes, outputPath);
        const registrations = this.generateRegistrations(classes, interfaceNames, '', abstractClassNames);

        const filename = outputPath.split('/').pop()?.replace(/\.ts$/, '') || 'container.gen';

        const dtsFilename = outputPath.split('/').pop()?.replace(/\.ts$/, '.d') || 'container.gen.d';

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 */
import { Container, Lifecycle } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './${dtsFilename}';
${imports}

export const container = new Container<ContainerRegistry>();

${registrations}
`;
    }

    private static generateModularFiles(
        moduleGroupedClasses: Map<string, ClassInfo[]>,
        outputPath: string
    ): void {
        const outputDir = dirname(outputPath);
        const baseFilename = basename(outputPath, '.ts');
        const modulesDir = join(outputDir, 'modules');

        // Create modules directory
        mkdirSync(modulesDir, { recursive: true });

        // Collect all interface names
        const allClasses = Array.from(moduleGroupedClasses.values()).flat();
        const interfaceNames = new Set<string>();
        allClasses.forEach(cls => {
            if (cls.interfaceName) {
                interfaceNames.add(cls.interfaceName);
            }
        });

        // Generate each module file
        const moduleImports: string[] = [];
        for (const [moduleName, classes] of moduleGroupedClasses.entries()) {
            const moduleFilename = `${moduleName.charAt(0).toLowerCase() + moduleName.slice(1)}.module.ts`;
            const moduleFilePath = join(modulesDir, moduleFilename);
            const moduleCode = this.generateModuleFile(moduleName, classes, interfaceNames, moduleFilePath);

            writeFileSync(moduleFilePath, moduleCode);

            // Add import for main container file
            const moduleVarName = moduleName.charAt(0).toLowerCase() + moduleName.slice(1);
            moduleImports.push(`import { ${moduleVarName} } from './modules/${moduleFilename.replace('.ts', '')}';`);
        }

        // Generate main container file
        const dtsFilename = baseFilename.replace(/\.gen$/, '.gen.d');
        const mainContainerCode = this.generateMainContainerFile(moduleGroupedClasses, moduleImports, dtsFilename);
        writeFileSync(outputPath, mainContainerCode);
    }

    private static generateModuleFile(
        moduleName: string,
        classes: ClassInfo[],
        interfaceNames: Set<string>,
        moduleFilePath: string
    ): string {
        const imports = this.generateImports(classes, moduleFilePath);

        // Collect abstract class names that are dependencies
        const abstractClassNames = new Set<string>();
        classes.forEach(cls => {
            cls.dependencies.forEach(dep => {
                const isInCurrentModule = classes.some(c => c.name === dep.name);
                const looksLikeAbstractClass = dep.name.startsWith('Abstract') || dep.name.includes('Abstract');
                if (!isInCurrentModule && looksLikeAbstractClass) {
                    abstractClassNames.add(dep.name);
                }
            });
        });

        const registrations = this.generateModuleRegistrations(classes, interfaceNames, abstractClassNames);
        const moduleVarName = moduleName.charAt(0).toLowerCase() + moduleName.slice(1);

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 * 
 * Module: ${moduleName}
 */
import { ContainerModule, Lifecycle } from '@notjustcoders/di-container';
${imports}

export const ${moduleVarName} = new ContainerModule()
${registrations};
`;
    }

    private static generateMainContainerFile(
        moduleGroupedClasses: Map<string, ClassInfo[]>,
        moduleImports: string[],
        dtsFilename: string
    ): string {
        const moduleInstantiations = Array.from(moduleGroupedClasses.keys())
            .map(name => {
                const varName = name.charAt(0).toLowerCase() + name.slice(1);
                return `container.registerModule(${varName});`;
            })
            .join('\n');

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 */
import { Container } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './${dtsFilename}';
${moduleImports.join('\n')}

export const container = new Container<ContainerRegistry>();

${moduleInstantiations}
`;
    }

    private static generateModularCode(
        moduleGroupedClasses: Map<string, ClassInfo[]>,
        outputPath: string
    ): string {
        const allClasses = Array.from(moduleGroupedClasses.values()).flat();

        // Collect all interface names
        const interfaceNames = new Set<string>();
        allClasses.forEach(cls => {
            if (cls.interfaceName) {
                interfaceNames.add(cls.interfaceName);
            }
        });

        const imports = this.generateImports(allClasses, outputPath);
        const moduleDefinitions = this.generateModuleDefinitions(moduleGroupedClasses, interfaceNames);
        const moduleInstantiations = this.generateModuleInstantiations(moduleGroupedClasses);

        const filename = outputPath.split('/').pop()?.replace(/\.ts$/, '') || 'container.gen';

        const dtsFilename = outputPath.split('/').pop()?.replace(/\.ts$/, '.d') || 'container.gen.d';

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 */
import { Container, ContainerModule, Lifecycle } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './${dtsFilename}';
${imports}

${moduleDefinitions}

export const container = new Container<ContainerRegistry>();

${moduleInstantiations}
`;
    }

    private static generateModuleDefinitions(
        moduleGroupedClasses: Map<string, ClassInfo[]>,
        interfaceNames: Set<string>
    ): string {
        const modules: string[] = [];

        for (const [moduleName, classes] of moduleGroupedClasses.entries()) {
            const registrations = this.generateModuleRegistrations(classes, interfaceNames);

            modules.push(`const ${moduleName.charAt(0).toLowerCase() + moduleName.slice(1)} = new ContainerModule()
${registrations};`);
        }

        return modules.join('\n\n');
    }

    private static generateModuleInstantiations(
        moduleGroupedClasses: Map<string, ClassInfo[]>
    ): string {
        const moduleNames = Array.from(moduleGroupedClasses.keys());
        const instantiations = moduleNames.map(name => {
            const varName = name.charAt(0).toLowerCase() + name.slice(1);
            return `container.registerModule(${varName});`;
        });

        return instantiations.join('\n');
    }

    private static generateModuleRegistrations(
        classes: ClassInfo[],
        interfaceNames: Set<string>,
        abstractClassNames: Set<string> = new Set()
    ): string {
        return classes.map(cls => {
            // Determine registration token
            const token = cls.interfaceName
                ? `'${cls.interfaceName}'`
                : cls.abstractClassName
                    ? `'${cls.abstractClassName}'`
                    : cls.name;

            // Generate dependencies array
            const dependencies = cls.dependencies.length > 0
                ? `, dependencies: [${cls.dependencies.map(dep => {
                    // If dependency is an interface, use string token
                    if (interfaceNames.has(dep.name)) {
                        return `'${dep.name}'`;
                    }

                    // If dependency is an abstract class, use string token
                    if (abstractClassNames.has(dep.name)) {
                        return `'${dep.name}'`;
                    }

                    // Use original class name
                    return dep.name;
                }).join(', ')}]`
                : '';

            // Determine lifecycle enum value
            const lifecycle = cls.scope === 'singleton'
                ? 'Lifecycle.Singleton'
                : 'Lifecycle.Transient';

            return `  .register(${token}, { useClass: ${cls.name}${dependencies}, lifecycle: ${lifecycle} })`;
        }).join('\n');
    }

    private static generateImports(classes: ClassInfo[], outputPath: string): string {
        const outputDir = dirname(outputPath);
        const importStatements: string[] = [];

        classes.forEach(cls => {
            // Calculate relative path from output file to class file
            let relativePath = relative(outputDir, cls.filePath);

            // Remove extension (.ts)
            relativePath = relativePath.replace(/\.ts$/, '');

            // Add ./ if it doesn't start with . or /
            if (!relativePath.startsWith('.')) {
                relativePath = `./${relativePath}`;
            }

            // Use forward slashes for imports
            relativePath = relativePath.replace(/\\/g, '/');

            importStatements.push(`import { ${cls.name} } from '${relativePath}';`);
        });

        return importStatements.join('\n');
    }

    /**
     * Checks for class name collisions and throws an error if any are found
     */
    private static checkForNameCollisions(classes: ClassInfo[]): void {
        const nameToClasses = new Map<string, ClassInfo[]>();

        classes.forEach(cls => {
            if (!nameToClasses.has(cls.name)) {
                nameToClasses.set(cls.name, []);
            }
            nameToClasses.get(cls.name)!.push(cls);
        });

        // Check for collisions
        for (const [className, classesWithSameName] of nameToClasses.entries()) {
            if (classesWithSameName.length > 1) {
                const filePaths = classesWithSameName.map(cls => cls.filePath);
                throw ErrorFactory.classNameCollision(className, filePaths);
            }
        }
    }


    private static generateRegistrations(
        classes: ClassInfo[],
        interfaceNames: Set<string>,
        indent: string = '',
        abstractClassNames: Set<string> = new Set()
    ): string {
        return classes.map(cls => {
            // Determine registration token:
            // - If implements interface, use string token of interface name
            // - If extends abstract class, use string token of abstract class name
            // - Otherwise, use class constructor
            const token = cls.interfaceName
                ? `'${cls.interfaceName}'`
                : cls.abstractClassName
                    ? `'${cls.abstractClassName}'`
                    : cls.name;

            // Generate dependencies array
            const dependencies = cls.dependencies.length > 0
                ? `\n${indent}  dependencies: [${cls.dependencies.map(dep => {
                    // If dependency is an interface, use string token
                    if (interfaceNames.has(dep.name)) {
                        return `'${dep.name}'`;
                    }

                    // If dependency is an abstract class, use string token
                    if (abstractClassNames.has(dep.name)) {
                        return `'${dep.name}'`;
                    }

                    // Use original class name
                    return dep.name;
                }).join(', ')}],`
                : '';

            // Determine lifecycle enum value
            const lifecycle = cls.scope === 'singleton'
                ? 'Lifecycle.Singleton'
                : 'Lifecycle.Transient';

            return `${indent}container.register(${token}, {
${indent}  useClass: ${cls.name},${dependencies}
${indent}  lifecycle: ${lifecycle},
${indent}});`;
        }).join('\n\n');
    }
}
