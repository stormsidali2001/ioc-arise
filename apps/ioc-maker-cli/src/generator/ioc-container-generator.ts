import { ClassInfo } from '../types';
import { relative, dirname, join, basename } from 'path';
import { writeFileSync, mkdirSync } from 'fs';
import { TypeDeclarationGenerator } from './type-declaration-generator';

export class IoCContainerGenerator {
    /**
     * Generates the IoC container code for the given classes
     * @param classes - Analyzed classes to be registered (can be flat or grouped)
     * @param outputPath - Path where the container file will be generated
     * @param moduleGroupedClasses - Optional: Classes grouped by modules
     */
    static generate(
        classes: ClassInfo[],
        outputPath: string,
        moduleGroupedClasses?: Map<string, ClassInfo[]>
    ): void {
        // Ensure directory exists
        const outputDir = dirname(outputPath);
        mkdirSync(outputDir, { recursive: true });

        if (moduleGroupedClasses && moduleGroupedClasses.size > 1) {
            // Generate modular code with separate files for each module
            this.generateModularFiles(moduleGroupedClasses, outputPath);
        } else {
            // Generate single flat file
            const containerCode = this.generateFlatCode(classes, outputPath);
            writeFileSync(outputPath, containerCode);
        }

        // Generate type declarations (.d.ts file)
        const typesPath = outputPath.endsWith('.gen.ts')
            ? outputPath.replace(/\.gen\.ts$/, '.gen.d.ts')
            : outputPath.replace(/\.ts$/, '.d.ts');
        TypeDeclarationGenerator.generate(classes, typesPath);
    }

    private static generateFlatCode(classes: ClassInfo[], outputPath: string): string {
        // Collect all interface names to identify which dependencies should use string tokens
        const interfaceNames = new Set<string>();
        classes.forEach(cls => {
            if (cls.interfaceName) {
                interfaceNames.add(cls.interfaceName);
            }
        });

        // Collect abstract class names from dependencies
        const abstractClassNames = new Set<string>();
        classes.forEach(cls => {
            cls.dependencies.forEach(dep => {
                const isInCurrentClasses = classes.some(c => c.name === dep.name);
                const looksLikeAbstractClass = dep.name.startsWith('Abstract') || dep.name.includes('Abstract');
                if (!isInCurrentClasses && looksLikeAbstractClass) {
                    abstractClassNames.add(dep.name);
                }
            });
        });

        const imports = this.generateImports(classes, outputPath);
        const registrations = this.generateRegistrations(classes, interfaceNames, '', abstractClassNames);

        const filename = outputPath.split('/').pop()?.replace(/\.ts$/, '') || 'container.gen';

        const dtsFilename = outputPath.split('/').pop()?.replace(/\.ts$/, '.d') || 'container.gen.d';

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 */
import { Container, Lifecycle } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './${dtsFilename}';
${imports}

export const container = new Container<ContainerRegistry>();

${registrations}
`;
    }

    private static generateModularFiles(
        moduleGroupedClasses: Map<string, ClassInfo[]>,
        outputPath: string
    ): void {
        const outputDir = dirname(outputPath);
        const baseFilename = basename(outputPath, '.ts');
        const modulesDir = join(outputDir, 'modules');

        // Create modules directory
        mkdirSync(modulesDir, { recursive: true });

        // Collect all interface names
        const allClasses = Array.from(moduleGroupedClasses.values()).flat();
        const interfaceNames = new Set<string>();
        allClasses.forEach(cls => {
            if (cls.interfaceName) {
                interfaceNames.add(cls.interfaceName);
            }
        });

        // Generate each module file
        const moduleImports: string[] = [];
        for (const [moduleName, classes] of moduleGroupedClasses.entries()) {
            const moduleFilename = `${moduleName.charAt(0).toLowerCase() + moduleName.slice(1)}.module.ts`;
            const moduleFilePath = join(modulesDir, moduleFilename);
            const moduleCode = this.generateModuleFile(moduleName, classes, interfaceNames, moduleFilePath);

            writeFileSync(moduleFilePath, moduleCode);

            // Add import for main container file
            const moduleVarName = moduleName.charAt(0).toLowerCase() + moduleName.slice(1);
            moduleImports.push(`import { ${moduleVarName} } from './modules/${moduleFilename.replace('.ts', '')}';`);
        }

        // Generate main container file
        const dtsFilename = baseFilename.replace(/\.gen$/, '.gen.d');
        const mainContainerCode = this.generateMainContainerFile(moduleGroupedClasses, moduleImports, dtsFilename);
        writeFileSync(outputPath, mainContainerCode);
    }

    private static generateModuleFile(
        moduleName: string,
        classes: ClassInfo[],
        interfaceNames: Set<string>,
        moduleFilePath: string
    ): string {
        const imports = this.generateImports(classes, moduleFilePath);

        // Collect abstract class names that are dependencies
        const abstractClassNames = new Set<string>();
        classes.forEach(cls => {
            cls.dependencies.forEach(dep => {
                const isInCurrentModule = classes.some(c => c.name === dep.name);
                const looksLikeAbstractClass = dep.name.startsWith('Abstract') || dep.name.includes('Abstract');
                if (!isInCurrentModule && looksLikeAbstractClass) {
                    abstractClassNames.add(dep.name);
                }
            });
        });

        const registrations = this.generateModuleRegistrations(classes, interfaceNames, abstractClassNames);
        const moduleVarName = moduleName.charAt(0).toLowerCase() + moduleName.slice(1);

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 * 
 * Module: ${moduleName}
 */
import { ContainerModule, Lifecycle } from '@notjustcoders/di-container';
${imports}

export const ${moduleVarName} = new ContainerModule()
${registrations};
`;
    }

    private static generateMainContainerFile(
        moduleGroupedClasses: Map<string, ClassInfo[]>,
        moduleImports: string[],
        dtsFilename: string
    ): string {
        const moduleInstantiations = Array.from(moduleGroupedClasses.keys())
            .map(name => {
                const varName = name.charAt(0).toLowerCase() + name.slice(1);
                return `container.registerModule(${varName});`;
            })
            .join('\n');

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 */
import { Container } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './${dtsFilename}';
${moduleImports.join('\n')}

export const container = new Container<ContainerRegistry>();

${moduleInstantiations}
`;
    }

    private static generateModularCode(
        moduleGroupedClasses: Map<string, ClassInfo[]>,
        outputPath: string
    ): string {
        const allClasses = Array.from(moduleGroupedClasses.values()).flat();

        // Collect all interface names
        const interfaceNames = new Set<string>();
        allClasses.forEach(cls => {
            if (cls.interfaceName) {
                interfaceNames.add(cls.interfaceName);
            }
        });

        const imports = this.generateImports(allClasses, outputPath);
        const moduleDefinitions = this.generateModuleDefinitions(moduleGroupedClasses, interfaceNames);
        const moduleInstantiations = this.generateModuleInstantiations(moduleGroupedClasses);

        const filename = outputPath.split('/').pop()?.replace(/\.ts$/, '') || 'container.gen';

        const dtsFilename = outputPath.split('/').pop()?.replace(/\.ts$/, '.d') || 'container.gen.d';

        return `/**
 * This file is auto-generated by ioc-arise.
 * Do not modify this file manually.
 */
import { Container, ContainerModule, Lifecycle } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './${dtsFilename}';
${imports}

${moduleDefinitions}

export const container = new Container<ContainerRegistry>();

${moduleInstantiations}
`;
    }

    private static generateModuleDefinitions(
        moduleGroupedClasses: Map<string, ClassInfo[]>,
        interfaceNames: Set<string>
    ): string {
        const modules: string[] = [];

        for (const [moduleName, classes] of moduleGroupedClasses.entries()) {
            const registrations = this.generateModuleRegistrations(classes, interfaceNames);

            modules.push(`const ${moduleName.charAt(0).toLowerCase() + moduleName.slice(1)} = new ContainerModule()
${registrations};`);
        }

        return modules.join('\n\n');
    }

    private static generateModuleInstantiations(
        moduleGroupedClasses: Map<string, ClassInfo[]>
    ): string {
        const moduleNames = Array.from(moduleGroupedClasses.keys());
        const instantiations = moduleNames.map(name => {
            const varName = name.charAt(0).toLowerCase() + name.slice(1);
            return `container.registerModule(${varName});`;
        });

        return instantiations.join('\n');
    }

    private static generateModuleRegistrations(
        classes: ClassInfo[],
        interfaceNames: Set<string>,
        abstractClassNames: Set<string> = new Set()
    ): string {
        return classes.map(cls => {
            // Get the aliased class name (or original if no alias)
            const className = this.classNameAliases.get(cls.filePath) || cls.name;

            // Determine registration token
            const token = cls.interfaceName
                ? `'${cls.interfaceName}'`
                : cls.abstractClassName
                    ? `'${cls.abstractClassName}'`
                    : className;

            // Generate dependencies array
            const dependencies = cls.dependencies.length > 0
                ? `, dependencies: [${cls.dependencies.map(dep => {
                    // If dependency is an interface, use string token
                    if (interfaceNames.has(dep.name)) {
                        return `'${dep.name}'`;
                    }

                    // If dependency is an abstract class, use string token
                    if (abstractClassNames.has(dep.name)) {
                        return `'${dep.name}'`;
                    }

                    // Check if this dependency name has collisions (multiple aliases)
                    const aliasMap = this.classNameToAliasMap.get(dep.name);
                    if (aliasMap && aliasMap.size > 0) {
                        // Resolve which specific alias to use based on import path
                        const depFilePath = this.resolveDependencyFilePath(cls.filePath, dep.importPath, dep.name);
                        const alias = this.classNameAliases.get(depFilePath);
                        if (alias) {
                            return alias;
                        }
                    }

                    // No collision or couldn't resolve - use original name
                    return dep.name;
                }).join(', ')}]`
                : '';

            // Determine lifecycle enum value
            const lifecycle = cls.scope === 'singleton'
                ? 'Lifecycle.Singleton'
                : 'Lifecycle.Transient';

            return `  .register(${token}, { useClass: ${className}${dependencies}, lifecycle: ${lifecycle} })`;
        }).join('\n');
    }

    private static generateImports(classes: ClassInfo[], outputPath: string): string {
        const outputDir = dirname(outputPath);

        // Detect name collisions and create aliases
        const nameToClasses = new Map<string, ClassInfo[]>();
        classes.forEach(cls => {
            if (!nameToClasses.has(cls.name)) {
                nameToClasses.set(cls.name, []);
            }
            nameToClasses.get(cls.name)!.push(cls);
        });

        const importStatements: string[] = [];
        const classNameAliases = new Map<string, string>(); // filePath -> alias
        const classNameToAliasMap = new Map<string, Map<string, string>>(); // className -> (filePath -> alias)

        classes.forEach(cls => {
            // Calculate relative path from output file to class file
            let relativePath = relative(outputDir, cls.filePath);

            // Remove extension (.ts)
            relativePath = relativePath.replace(/\.ts$/, '');

            // Add ./ if it doesn't start with . or /
            if (!relativePath.startsWith('.')) {
                relativePath = `./${relativePath}`;
            }

            // Use forward slashes for imports
            relativePath = relativePath.replace(/\\/g, '/');

            // Check if this class name has collisions
            const classesWithSameName = nameToClasses.get(cls.name) || [];
            if (classesWithSameName.length > 1) {
                // Name collision detected - create an alias
                // Use the parent directory name as prefix (e.g., user/UpdateItemUseCase -> UserUpdateItemUseCase)
                const pathParts = cls.filePath.split('/');
                const parentDir = pathParts[pathParts.length - 2] || 'Item';
                const alias = `${parentDir.charAt(0).toUpperCase() + parentDir.slice(1)}${cls.name}`;

                classNameAliases.set(cls.filePath, alias);

                // Track alias by class name too
                if (!classNameToAliasMap.has(cls.name)) {
                    classNameToAliasMap.set(cls.name, new Map());
                }
                classNameToAliasMap.get(cls.name)!.set(cls.filePath, alias);

                importStatements.push(`import { ${cls.name} as ${alias} } from '${relativePath}';`);
            } else {
                // No collision - use regular import
                classNameAliases.set(cls.filePath, cls.name);
                importStatements.push(`import { ${cls.name} } from '${relativePath}';`);
            }
        });

        // Store aliases for use in registrations
        this.classNameAliases = classNameAliases;
        this.classNameToAliasMap = classNameToAliasMap;

        return importStatements.join('\n');
    }

    private static classNameAliases = new Map<string, string>(); // filePath -> alias
    private static classNameToAliasMap = new Map<string, Map<string, string>>(); // className -> (filePath -> alias)

    /**
     * Resolves the full file path of a dependency based on the importing file and relative import path
     */
    private static resolveDependencyFilePath(importerFilePath: string, relativeImportPath: string, depName: string): string {
        const importerDir = dirname(importerFilePath);
        const resolvedPath = join(importerDir, relativeImportPath);

        // Try with .ts extension first
        if (resolvedPath.endsWith('.ts')) {
            return resolvedPath;
        }

        // Add .ts extension and normalize
        const withExtension = `${resolvedPath}.ts`;
        return withExtension;
    }


    private static generateRegistrations(
        classes: ClassInfo[],
        interfaceNames: Set<string>,
        indent: string = '',
        abstractClassNames: Set<string> = new Set()
    ): string {
        return classes.map(cls => {
            // Get the aliased class name (or original if no alias)
            const className = this.classNameAliases.get(cls.filePath) || cls.name;

            // Determine registration token:
            // - If implements interface, use string token of interface name
            // - If extends abstract class, use string token of abstract class name
            // - Otherwise, use class constructor
            const token = cls.interfaceName
                ? `'${cls.interfaceName}'`
                : cls.abstractClassName
                    ? `'${cls.abstractClassName}'`
                    : className;

            // Generate dependencies array
            const dependencies = cls.dependencies.length > 0
                ? `\n${indent}  dependencies: [${cls.dependencies.map(dep => {
                    // If dependency is an interface, use string token
                    if (interfaceNames.has(dep.name)) {
                        return `'${dep.name}'`;
                    }

                    // If dependency is an abstract class, use string token
                    if (abstractClassNames.has(dep.name)) {
                        return `'${dep.name}'`;
                    }

                    // Check if this dependency name has collisions (multiple aliases)
                    const aliasMap = this.classNameToAliasMap.get(dep.name);
                    if (aliasMap && aliasMap.size > 0) {
                        // We need to resolve which specific alias to use based on import path
                        // Try to find the matching class by resolving the import path
                        const depFilePath = this.resolveDependencyFilePath(cls.filePath, dep.importPath, dep.name);
                        const alias = this.classNameAliases.get(depFilePath);
                        if (alias) {
                            return alias;
                        }
                    }

                    // No collision or couldn't resolve - use original name
                    return dep.name;
                }).join(', ')}],`
                : '';

            // Determine lifecycle enum value
            const lifecycle = cls.scope === 'singleton'
                ? 'Lifecycle.Singleton'
                : 'Lifecycle.Transient';

            return `${indent}container.register(${token}, {
${indent}  useClass: ${className},${dependencies}
${indent}  lifecycle: ${lifecycle},
${indent}});`;
        }).join('\n\n');
    }
}
