---
title: Clean Architecture Example
description: Advanced example demonstrating Clean Architecture principles with use cases, ports, adapters, and presenters
sidebar:
  order: 3
---

import { FileTree, Card, CardGrid, Badge, Tabs, TabItem } from '@astrojs/starlight/components';

<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0 2rem 0;">
  <Badge text="Clean Architecture" variant="tip" />
  <Badge text="Ports & Adapters" variant="success" />
  <Badge text="Advanced" variant="caution" />
</div>

:::tip[üéØ What You'll Learn]
This advanced example demonstrates **production-grade Clean Architecture** with IoC Arise:
- **Hexagonal Architecture** - Ports and adapters pattern for complete decoupling
- **Use Case Driven** - Business logic organized around user intentions
- **DTO Pattern** - Clear data contracts between layers
- **Presenter Pattern** - Separation of presentation logic from business logic
- **Aggregate Roots** - User entity manages Todo entities as an aggregate
:::

## Project Structure

<FileTree>
- clean-architecture/
  - entities/
    - Todo.ts
    - User.ts
  - dtos/
    - TodoDTOs.ts
    - UserDTOs.ts
  - ports/
    - IInputPort.ts
    - IOutputPort.ts
    - ITodoInputPort.ts
    - ITodoOutputPort.ts
  - use-cases/
    - CreateTodoUseCase.ts
    - GetTodoUseCase.ts
    - UpdateTodoUseCase.ts
    - DeleteTodoUseCase.ts
    - GetTodosByUserUseCase.ts
    - CreateUserUseCase.ts
    - GetUserUseCase.ts
    - DeleteUserUseCase.ts
  - repositories/
    - ITodoRepository.ts
    - TodoRepository.ts
    - IUserRepository.ts
    - UserRepository.ts
  - presenters/
    - CreateTodoPresenter.ts
    - GetTodoPresenter.ts
    - UpdateTodoPresenter.ts
    - DeleteTodoPresenter.ts
    - GetTodosByUserPresenter.ts
    - CreateUserPresenter.ts
    - GetUserPresenter.ts
    - DeleteUserPresenter.ts
  - view-models/
    - TodoViewModels.ts
    - UserViewModels.ts
  - ioc.config.json
  - container.gen.ts
</FileTree>

## Clean Architecture Layers

<CardGrid>
  <Card title="üèõÔ∏è Entities" icon="seti:config">
    **Core business logic** - User and Todo aggregates with validation rules and business invariants.
  </Card>
  <Card title="üéØ Use Cases" icon="rocket">
    **Application business rules** - Orchestrate flow of data between entities and output ports.
  </Card>
  <Card title="üîå Ports" icon="puzzle">
    **Interfaces for I/O** - Input ports (use cases) and output ports (presenters) define boundaries.
  </Card>
  <Card title="üîÑ Adapters" icon="approve-check">
    **Implementation details** - Repositories, presenters, and infrastructure adapters.
  </Card>
</CardGrid>

## Entities (Domain Layer)

<Tabs>
  <TabItem label="User Aggregate">

**User Aggregate Root** - manages Todo entities:

```typescript
// entities/User.ts
export interface CreateUserData {
  email: string;
  name: string;
}

// User Aggregate Root - manages Todo entities
export class User {
  private _todos: Map<string, Todo> = new Map();

  constructor(
    public readonly id: string,
    private _email: string,
    private _name: string,
    public readonly createdAt: Date = new Date()
  ) {
    this.validateEmail(_email);
    this.validateName(_name);
  }

  get email(): string {
    return this._email;
  }

  get name(): string {
    return this._name;
  }

  get todos(): Todo[] {
    return Array.from(this._todos.values());
  }

  // Critical business logic: Email validation
  private validateEmail(email: string): void {
    const emailRegex = /^[^
@]+@[^
@]+\.[^
@]+$/;
    if (!emailRegex.test(email)) {
      throw new Error('Invalid email format');
    }
  }

  // Critical business logic: Name validation
  private validateName(name: string): void {
    if (!name || name.trim().length < 2) {
      throw new Error('Name must be at least 2 characters long');
    }
    if (name.trim().length > 100) {
      throw new Error('Name cannot exceed 100 characters');
    }
  }

  // Critical business logic: Update email with validation
  updateEmail(newEmail: string): void {
    this.validateEmail(newEmail);
    this._email = newEmail;
  }

  // Critical business logic: Update name with validation
  updateName(newName: string): void {
    this.validateName(newName);
    this._name = newName;
  }

  // Critical business logic: Get display name
  getDisplayName(): string {
    return this._name.trim();
  }

  // Critical business logic: Check if user has valid contact info
  hasValidContactInfo(): boolean {
    return this.email.length > 0 && this.name.trim().length > 0;
  }

  // Aggregate business logic: Add a new todo
  addTodo(todoData: CreateTodoData): Todo {
    if (todoData.userId !== this.id) {
      throw new Error('Todo must belong to this user');
    }

    // Business rule: User cannot have more than 100 todos
    if (this._todos.size >= 100) {
      throw new Error('User cannot have more than 100 todos');
    }

    // Business rule: User cannot have duplicate todo titles
    const existingTodo = Array.from(this._todos.values())
      .find(todo => todo.title.toLowerCase() === todoData.title.toLowerCase());
    if (existingTodo) {
      throw new Error('User already has a todo with this title');
    }

    const todo = Todo.create(todoData);
    this._todos.set(todo.id, todo);
    return todo;
  }

  // Aggregate business logic: Get a specific todo
  getTodo(todoId: string): Todo | null {
    return this._todos.get(todoId) || null;
  }

  // Aggregate business logic: Update a todo
  updateTodo(todoId: string, updateData: UpdateTodoData): Todo {
    const todo = this._todos.get(todoId);
    if (!todo) {
      throw new Error('Todo not found');
    }

    // Business rule: Check for duplicate titles when updating
    if (updateData.title) {
      const existingTodo = Array.from(this._todos.values())
        .find(t => t.id !== todoId && t.title.toLowerCase() === updateData.title!.toLowerCase());
      if (existingTodo) {
        throw new Error('User already has a todo with this title');
      }
    }

    todo.update(updateData);
    return todo;
  }

  // Aggregate business logic: Remove a todo
  removeTodo(todoId: string): boolean {
    return this._todos.delete(todoId);
  }

  // Aggregate business logic: Get completed todos
  getCompletedTodos(): Todo[] {
    return Array.from(this._todos.values()).filter(todo => todo.completed);
  }

  // Aggregate business logic: Get pending todos
  getPendingTodos(): Todo[] {
    return Array.from(this._todos.values()).filter(todo => !todo.completed);
  }

  // Aggregate business logic: Get todos by priority
  getTodosByPriority(priority: 'high' | 'medium' | 'low'): Todo[] {
    return Array.from(this._todos.values()).filter(todo => todo.getPriority() === priority);
  }

  // Aggregate business logic: Mark all todos as completed
  completeAllTodos(): void {
    for (const todo of Array.from(this._todos.values())) {
      if (!todo.completed) {
        todo.markAsCompleted();
      }
    }
  }

  // Aggregate business logic: Get todo statistics
  getTodoStats(): { total: number; completed: number; pending: number; highPriority: number } {
    const todos = Array.from(this._todos.values());
    return {
      total: todos.length,
      completed: todos.filter(t => t.completed).length,
      pending: todos.filter(t => !t.completed).length,
      highPriority: todos.filter(t => t.getPriority() === 'high').length
    };
  }

  // Aggregate business logic: Check if user is productive (has completed todos)
  isProductive(): boolean {
    return this.getCompletedTodos().length > 0;
  }

  // Factory method for creating new users
  static create(data: CreateUserData): User {
    const id = crypto.randomUUID();
    return new User(id, data.email, data.name);
  }

  // Load existing todos into the aggregate (for repository loading)
  loadTodos(todos: Todo[]): void {
    this._todos.clear();
    for (const todo of todos) {
      if (todo.userId !== this.id) {
        throw new Error('Cannot load todo that does not belong to this user');
      }
      this._todos.set(todo.id, todo);
    }
  }

  // Convert to plain object for serialization
  toJSON(): object {
    return {
      id: this.id,
      email: this.email,
      name: this.name,
      createdAt: this.createdAt,
      todos: this.todos.map(todo => todo.toJSON())
    };
  }
}
```

**Key Features:**
‚Ä¢ Email & name validation  
‚Ä¢ Todo management (max 100, unique titles)  
‚Ä¢ Business rules enforcement  
‚Ä¢ Aggregate statistics

  </TabItem>
  <TabItem label="Todo Entity">

**Todo Entity** - with business logic and validation:

```typescript
// entities/Todo.ts
export interface CreateTodoData {
  title: string;
  description: string;
  userId: string;
}

export interface UpdateTodoData {
  title?: string;
  description?: string;
  completed?: boolean;
}

export class Todo {
  constructor(
    public readonly id: string,
    private _title: string,
    private _description: string,
    private _completed: boolean,
    public readonly userId: string,
    public readonly createdAt: Date = new Date(),
    private _updatedAt: Date = new Date()
  ) {
    this.validateTitle(_title);
    this.validateDescription(_description);
    this.validateUserId(userId);
  }

  get title(): string {
    return this._title;
  }

  get description(): string {
    return this._description;
  }

  get completed(): boolean {
    return this._completed;
  }

  get updatedAt(): Date {
    return this._updatedAt;
  }

  // Critical business logic: Title validation
  private validateTitle(title: string): void {
    if (!title || title.trim().length < 3) {
      throw new Error('Title must be at least 3 characters long');
    }
    if (title.trim().length > 200) {
      throw new Error('Title cannot exceed 200 characters');
    }
  }

  // Critical business logic: Description validation
  private validateDescription(description: string): void {
    if (description && description.length > 1000) {
      throw new Error('Description cannot exceed 1000 characters');
    }
  }

  // Critical business logic: User ID validation
  private validateUserId(userId: string): void {
    if (!userId || userId.trim().length === 0) {
      throw new Error('User ID is required');
    }
  }

  // Critical business logic: Update title with validation
  updateTitle(newTitle: string): void {
    this.validateTitle(newTitle);
    this._title = newTitle;
    this.touch();
  }

  // Critical business logic: Update description with validation
  updateDescription(newDescription: string): void {
    this.validateDescription(newDescription);
    this._description = newDescription;
    this.touch();
  }

  // Critical business logic: Mark as completed
  markAsCompleted(): void {
    if (this._completed) {
      throw new Error('Todo is already completed');
    }
    this._completed = true;
    this.touch();
  }

  // Critical business logic: Mark as incomplete
  markAsIncomplete(): void {
    if (!this._completed) {
      throw new Error('Todo is already incomplete');
    }
    this._completed = false;
    this.touch();
  }

  // Critical business logic: Toggle completion status
  toggleCompletion(): void {
    this._completed = !this._completed;
    this.touch();
  }

  // Critical business logic: Check if todo is overdue (if it has a due date)
  isOverdue(dueDate?: Date): boolean {
    if (!dueDate) return false;
    return !this._completed && new Date() > dueDate;
  }

  // Critical business logic: Get todo priority based on age and completion
  getPriority(): 'high' | 'medium' | 'low' {
    if (this._completed) return 'low';
    
    const daysSinceCreated = Math.floor(
      (Date.now() - this.createdAt.getTime()) / (1000 * 60 * 60 * 24)
    );
    
    if (daysSinceCreated > 7) return 'high';
    if (daysSinceCreated > 3) return 'medium';
    return 'low';
  }

  // Critical business logic: Check if todo belongs to user
  belongsToUser(userId: string): boolean {
    return this.userId === userId;
  }

  // Critical business logic: Get summary for display
  getSummary(maxLength: number = 50): string {
    const summary = this._title.length > maxLength 
      ? this._title.substring(0, maxLength) + '...'
      : this._title;
    return `${this._completed ? '‚úì' : '‚óã'} ${summary}`;
  }

  // Update the updatedAt timestamp
  private touch(): void {
    this._updatedAt = new Date();
  }

  // Factory method for creating new todos
  static create(data: CreateTodoData): Todo {
    const id = crypto.randomUUID();
    return new Todo(id, data.title, data.description, false, data.userId);
  }

  // Update todo with partial data
  update(data: UpdateTodoData): void {
    if (data.title !== undefined) {
      this.updateTitle(data.title);
    }
    if (data.description !== undefined) {
      this.updateDescription(data.description);
    }
    if (data.completed !== undefined) {
      if (data.completed && !this._completed) {
        this.markAsCompleted();
      } else if (!data.completed && this._completed) {
        this.markAsIncomplete();
      }
    }
  }

  // Convert to plain object for serialization
  toJSON(): object {
    return {
      id: this.id,
      title: this.title,
      description: this.description,
      completed: this.completed,
      userId: this.userId,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt
    };
  }
}
```

**Key Features:**
‚Ä¢ Title & description validation  
‚Ä¢ Completion status management  
‚Ä¢ Priority calculation (based on age)  
‚Ä¢ Belongs to user enforcement

  </TabItem>
</Tabs>

## Use Cases (Application Layer)

:::note[üí° Use Case Pattern]
Each use case represents a single user intention and orchestrates the flow between entities, repositories, and output ports.
:::

<Tabs>
  <TabItem label="Create Todo">

**CreateTodoUseCase** - adds todo through user aggregate:

```typescript
// use-cases/CreateTodoUseCase.ts
export class CreateTodoUseCase implements ICreateTodoInputPort {
  constructor(
    private userRepository: IUserRepository,
    private outputPort: ICreateTodoOutputPort
  ) {}

  async execute(todoData: CreateTodoRequestDTO): Promise<void> {
    try {
      // Validate input
      if (!todoData.title.trim()) {
        this.outputPort.presentError('Todo title is required');
        return;
      }

      if (!todoData.userId.trim()) {
        this.outputPort.presentError('User ID is required');
        return;
      }

      // Get the user aggregate
      const user = await this.userRepository.findById(todoData.userId);
      if (!user) {
        this.outputPort.presentError('User not found');
        return;
      }

      // Create todo through the user aggregate
      const createData: CreateTodoData = {
        title: todoData.title.trim(),
        description: todoData.description.trim(),
        userId: todoData.userId
      };
      
      const todo = user.addTodo(createData);

      // Save the user aggregate (which includes the new todo)
      await this.userRepository.save(user);
      
      // Convert entity to DTO for presentation
      const todoDTO: TodoResponseDTO = {
        id: todo.id,
        title: todo.title,
        description: todo.description,
        completed: todo.completed,
        userId: todo.userId,
        createdAt: todo.createdAt.toISOString(),
        updatedAt: todo.updatedAt.toISOString()
      };
      
      this.outputPort.presentSuccess(todoDTO);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.outputPort.presentError(errorMessage);
    }
  }
}
```

  </TabItem>
  <TabItem label="Create User">

**CreateUserUseCase** - creates user with validation:

```typescript
// use-cases/CreateUserUseCase.ts
export class CreateUserUseCase implements ICreateUserInputPort {
  constructor(
    private userRepository: IUserRepository,
    private outputPort: OutputPort
  ) {}

  async execute(userData: CreateUserRequestDTO): Promise<void> {
    try {
      // Check if user already exists
      const existingUser = await this.userRepository.findByEmail(userData.email);
      if (existingUser) {
        this.outputPort.presentError('User with this email already exists');
        return;
      }

      // Create new user entity using factory method
      const createData: CreateUserData = {
        email: userData.email,
        name: userData.name
      };
      const user = User.create(createData);

      await this.userRepository.save(user);
      
      // Convert entity to DTO for presentation
      const userDTO: UserResponseDTO = {
        id: user.id,
        email: user.email,
        name: user.name,
        createdAt: user.createdAt.toISOString()
      };
      
      this.outputPort.presentSuccess(userDTO);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.outputPort.presentError(errorMessage);
    }
  }
}
```

  </TabItem>
  <TabItem label="Update/Delete">

**UpdateTodoUseCase** and **DeleteTodoUseCase** - modify todos through aggregate:

```typescript
// use-cases/DeleteTodoUseCase.ts
export class DeleteTodoUseCase implements IDeleteTodoInputPort {
  constructor(
    private userRepository: IUserRepository,
    private todoRepository: ITodoRepository,
    private outputPort: IDeleteTodoOutputPort
  ) {}

  async execute(request: DeleteTodoRequestDTO): Promise<void> {
    try {
      // First, find the todo to get its owner's userId
      const todo = await this.todoRepository.findById(request.id);
      
      if (!todo) {
        this.outputPort.presentNotFound();
        return;
      }
      
      // Now fetch only the specific user who owns this todo
      const ownerUser = await this.userRepository.findById(todo.userId);
      
      if (!ownerUser) {
        this.outputPort.presentNotFound();
        return;
      }

      // Remove todo through the user aggregate
      const wasRemoved = ownerUser.removeTodo(request.id);
      
      if (!wasRemoved) {
        this.outputPort.presentNotFound();
        return;
      }
      
      // Save the user aggregate
      await this.userRepository.save(ownerUser);
      
      this.outputPort.presentSuccess();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.outputPort.presentError(errorMessage);
    }
  }
}
```

**Key Pattern:**
‚Ä¢ Load aggregate from repository  
‚Ä¢ Execute business logic through aggregate  
‚Ä¢ Save aggregate back  
‚Ä¢ Present result via output port

  </TabItem>
  <TabItem label="Query Use Cases">

**GetTodoUseCase**, **GetUserUseCase**, etc. - query operations:

```typescript
// use-cases/GetTodosByUserUseCase.ts
export class GetTodosByUserUseCase implements IGetTodosByUserInputPort {
  constructor(
    private userRepository: IUserRepository,
    private outputPort: IGetTodosByUserOutputPort
  ) {}

  async execute(request: GetTodosByUserRequestDTO): Promise<void> {
    try {
      const user = await this.userRepository.findById(request.userId);
      
      if (!user) {
        this.outputPort.presentTodos([]);
        return;
      }
      
      // Get todos from user aggregate
      const todos = user.todos;
      
      // Convert entities to DTOs for presentation
      const todoDTOs: TodoResponseDTO[] = todos.map(todo => ({
        id: todo.id,
        title: todo.title,
        description: todo.description,
        completed: todo.completed,
        userId: todo.userId,
        createdAt: todo.createdAt.toISOString(),
        updatedAt: todo.updatedAt.toISOString()
      }));
      
      this.outputPort.presentTodos(todoDTOs);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.outputPort.presentError(errorMessage);
    }
  }
}
```

**Key Pattern:**
‚Ä¢ Query from repository  
‚Ä¢ Convert entity to DTO  
‚Ä¢ Present via output port  
‚Ä¢ No business logic changes

  </TabItem>
</Tabs>

## Ports (Boundary Interfaces)

:::note[üîå Ports Pattern]
Input ports define use case boundaries. Output ports define presentation boundaries. This inverts dependencies toward the domain!
:::

<Tabs>
  <TabItem label="Input Ports">

**Input Ports** - use case boundaries:

```typescript
// ports/IInputPort.ts
export interface ICreateUserInputPort {
  execute(userData: CreateUserRequestDTO): Promise<void>;
}

export interface IGetUserInputPort {
  execute(request: GetUserRequestDTO): Promise<void>;
}

export interface IDeleteUserInputPort {
  execute(request: DeleteUserRequestDTO): Promise<void>;
}
```

```typescript
// ports/ITodoInputPort.ts
export interface ICreateTodoInputPort {
  execute(todoData: CreateTodoRequestDTO): Promise<void>;
}

export interface IGetTodoInputPort {
  execute(request: GetTodoRequestDTO): Promise<void>;
}

export interface IGetTodosByUserInputPort {
  execute(request: GetTodosByUserRequestDTO): Promise<void>;
}

export interface IUpdateTodoInputPort {
  execute(request: UpdateTodoRequestDTO): Promise<void>;
}

export interface IDeleteTodoInputPort {
  execute(request: DeleteTodoRequestDTO): Promise<void>;
}

// ... and more input ports for each use case
```

One interface per use case - keeps boundaries clean!

  </TabItem>
  <TabItem label="Output Ports">

**Output Ports** - presentation boundaries:

```typescript
// ports/IOutputPort.ts
export interface ICreateUserOutputPort {
  presentSuccess(user: UserResponseDTO): void;
  presentError(error: string): void;
}

export interface IGetUserOutputPort {
  presentUser(user: UserResponseDTO): void;
  presentNotFound(): void;
  presentError(error: string): void;
}

export interface IDeleteUserOutputPort {
  presentSuccess(): void;
  presentNotFound(): void;
  presentError(error: string): void;
}
```

```typescript
// ports/ITodoOutputPort.ts
export interface ICreateTodoOutputPort {
  presentSuccess(todo: TodoResponseDTO): void;
  presentError(error: string): void;
}

export interface IGetTodoOutputPort {
  presentTodo(todo: TodoResponseDTO): void;
  presentNotFound(): void;
  presentError(error: string): void;
}

// ... and more output ports
```

Each output port defines how results are presented!

  </TabItem>
</Tabs>

## DTOs (Data Transfer Objects)

<Tabs>
  <TabItem label="Todo DTOs">

**Todo DTOs** - decoupled from entities:

```typescript
// dtos/TodoDTOs.ts - No entity dependencies!
export interface CreateTodoRequestDTO {
  title: string;
  description: string;
  userId: string;
}

export interface TodoResponseDTO {
  id: string;
  title: string;
  description: string;
  completed: boolean;
  userId: string;
  createdAt: string; // ISO string, not Date
  updatedAt: string;
}

export interface UpdateTodoRequestDTO {
  id: string;
  title?: string;
  description?: string;
  completed?: boolean;
}

// ... and more request/response DTOs
```

**Key:** DTOs use primitives and serializable types only!

  </TabItem>
  <TabItem label="User DTOs">

**User DTOs** - simple data contracts:

```typescript
// dtos/UserDTOs.ts
export interface CreateUserRequestDTO {
  email: string;
  name: string;
}

export interface UserResponseDTO {
  id: string;
  email: string;
  name: string;
  createdAt: string; // ISO string, not Date
}

export interface GetUserRequestDTO {
  id: string;
}

export interface DeleteUserRequestDTO {
  id: string;
}
```

**Benefits:**
‚Ä¢ No entity coupling  
‚Ä¢ Easy serialization  
‚Ä¢ Clear API contracts  
‚Ä¢ Version-friendly

  </TabItem>
</Tabs>

## Presenters (Output Adapters)

:::note[üìä Presenter Pattern]
Presenters implement output ports and transform DTOs into ViewModels. They're marked as `@scope transient` to handle per-request state!
:::

<Tabs>
  <TabItem label="Create Presenter">

**CreateTodoPresenter** - transforms results to view models:

```typescript
// presenters/CreateTodoPresenter.ts
/**
 * @scope transient
 */
export class CreateTodoPresenter implements ICreateTodoOutputPort {
  private viewModel: CreateTodoViewModel = {
    isLoading: false,
    isSuccess: false,
    isError: false,
    errorMessage: '',
    successMessage: '',
    todo: null
  };

  // Getter for ViewModel (for UI consumption)
  getViewModel(): CreateTodoViewModel {
    return { ...this.viewModel };
  }

  // View-related business logic methods
  setLoading(isLoading: boolean): void {
    this.viewModel.isLoading = isLoading;
    if (isLoading) {
      this.resetState();
    }
  }

  private resetState(): void {
    this.viewModel.isSuccess = false;
    this.viewModel.isError = false;
    this.viewModel.errorMessage = '';
    this.viewModel.successMessage = '';
    this.viewModel.todo = null;
  }

  // Output port implementations
  presentSuccess(todo: TodoResponseDTO): void {
    this.viewModel.isLoading = false;
    this.viewModel.isSuccess = true;
    this.viewModel.isError = false;
    this.viewModel.successMessage = `Todo '${todo.title}' created successfully`;
    this.viewModel.todo = {
      id: todo.id,
      title: todo.title,
      description: todo.description,
      completed: todo.completed,
      userId: todo.userId
    };
    
    // Console output for demo purposes
    console.log('Todo created successfully:', todo);
  }

  presentError(error: string): void {
    this.viewModel.isLoading = false;
    this.viewModel.isSuccess = false;
    this.viewModel.isError = true;
    this.viewModel.errorMessage = error;
    this.viewModel.todo = null;
    
    // Console output for demo purposes
    console.error('Error creating todo:', error);
  }

  // Legacy methods for backward compatibility
  getResult() {
    return {
      success: this.viewModel.isSuccess,
      todo: this.viewModel.todo,
      error: this.viewModel.errorMessage || undefined
    };
  }

  clearResult(): void {
    this.resetState();
  }
}
```

**Key Features:**
‚Ä¢ Transient scope (per-request state)  
‚Ä¢ Transforms DTO ‚Üí ViewModel  
‚Ä¢ Implements output port  
‚Ä¢ Manages loading/success/error states

  </TabItem>
  <TabItem label="Presenter Pattern">

**All presenters follow the same pattern:**

```typescript
/**
 * @scope transient  // ‚úÖ Each request gets fresh instance
 */
export class [Operation]Presenter implements I[Operation]OutputPort {
  private viewModel = {
    isLoading: false,
    isSuccess: false,
    isError: false,
    errorMessage: '',
    // ... state fields
  };

  getViewModel() {
    return { ...this.viewModel };
  }

  // Implement output port methods
  presentSuccess(data: DTO): void {
    // Transform DTO ‚Üí ViewModel
    // Update state flags
    // Log for demo/debugging
  }

  presentError(error: string): void {
    // Update error state
    // Clear data
    // Log error
  }
}
```

**All presenters** (CreateUser, CreateTodo, GetUser, GetTodo, UpdateTodo, DeleteTodo, GetTodosByUser) **follow this exact pattern!**

  </TabItem>
</Tabs>

## Configuration

:::note[‚öôÔ∏è Module Configuration]
Organize clean architecture by modules - group use cases, repositories, and presenters together!
:::

```json
{
  "sourceDir": ".",
  "outputPath": "container.gen.ts",
  "interface": "I*.ts",
  "modules": {
    "UserModule": [
      "use-cases/*User*",
      "repositories/UserRepository.ts",
      "presenters/*User*"
    ],
    "TodoModule": [
      "use-cases/*Todo*",
      "repositories/TodoRepository.ts",
      "presenters/*Todo*"
    ]
  }
}
```

## Usage Example

:::tip[üéØ Type-Safe Clean Architecture]
Resolve use cases and presenters with full IntelliSense. The aggregate pattern ensures business rules are enforced!
:::

<Tabs>
  <TabItem label="Basic Flow">

**Standard clean architecture flow:**

```typescript
import { container } from './container.gen';

// 1. Resolve use case and presenter
const createUserUseCase = container.resolve('ICreateUserInputPort');
const createUserPresenter = container.resolve('ICreateUserOutputPort');

// 2. Execute use case (writes to presenter)
await createUserUseCase.execute({
  name: 'John Doe',
  email: 'john@example.com'
});

// 3. Get view model from presenter
const result = createUserPresenter.getViewModel();

if (result.isSuccess) {
  console.log('User created:', result.user);
} else if (result.isError) {
  console.error('Error:', result.errorMessage);
}
```

  </TabItem>
  <TabItem label="Complete Workflow">

**Create user and add todos:**

```typescript
import { container } from './container.gen';

// Create user
const createUserUseCase = container.resolve('ICreateUserInputPort');
const createUserPresenter = container.resolve('ICreateUserOutputPort');

await createUserUseCase.execute({
  name: 'Alice',
  email: 'alice@example.com'
});

const userResult = createUserPresenter.getViewModel();

if (userResult.isSuccess) {
  // Create todo for user (demonstrates aggregate pattern)
  const createTodoUseCase = container.resolve('ICreateTodoInputPort');
  const createTodoPresenter = container.resolve('ICreateTodoOutputPort');
  
  await createTodoUseCase.execute({
    title: 'Learn Clean Architecture',
    description: 'Study the principles',
    userId: userResult.user!.id
  });
  
  const todoResult = createTodoPresenter.getViewModel();
  
  if (todoResult.isSuccess) {
    console.log('‚úÖ Todo created:', todoResult.todo);
  }
}
```

  </TabItem>
  <TabItem label="Aggregate Benefits">

**Why use aggregates?**

```typescript
// ‚ùå Without aggregates - business rules in use case
// await todoRepository.save(new Todo(...));  
// // No validation that user exists!
// // No check for duplicate titles!
// // No enforcement of max 100 todos!

// ‚úÖ With aggregates - business rules in entity
const user = await userRepository.findById(userId);
const todo = user.addTodo(todoData);  
// ‚úÖ Validates user exists
// ‚úÖ Checks for duplicate titles
// ‚úÖ Enforces max 100 todos limit
// ‚úÖ All business rules in one place!
await userRepository.save(user);
```

**Benefits:**
‚Ä¢ Business rules stay in entities  
‚Ä¢ Use cases remain thin orchestrators  
‚Ä¢ Consistency enforced by aggregates  
‚Ä¢ Easy to test business logic

  </TabItem>
</Tabs>

## Key Takeaways

<CardGrid>
  <Card title="üèõÔ∏è Clean Layers" icon="seti:config">
    **Entities ‚Üí Use Cases ‚Üí Ports ‚Üí Adapters**. Dependencies point inward toward the domain!
  </Card>
  <Card title="üéØ Aggregate Roots" icon="star">
    User aggregate manages Todo entities. Business rules enforced at the entity level.
  </Card>
  <Card title="üîå Ports & Adapters" icon="puzzle">
    Input ports (use cases) and output ports (presenters) define clear boundaries.
  </Card>
  <Card title="üì¶ DTOs Everywhere" icon="document">
    DTOs decouple layers. No entity dependencies in ports or presenters.
  </Card>
  <Card title="üìä Presenter Pattern" icon="approve-check">
    Presenters transform DTOs ‚Üí ViewModels with loading/success/error states.
  </Card>
  <Card title="üõ°Ô∏è Type Safety" icon="seti:typescript">
    Full IntelliSense for all tokens. Compile-time checking across all layers.
  </Card>
  <Card title="‚ö° Smart Scopes" icon="rocket">
    Singletons for use cases/repositories (stateless). Transients for presenters (per-request state).
  </Card>
  <Card title="üîÑ IoC Arise Magic" icon="magic">
    Zero decorators. Zero manual wiring. Just run the CLI and get production-ready clean architecture!
  </Card>
</CardGrid>

:::tip[üöÄ Production Ready]
This example demonstrates **enterprise-grade Clean Architecture** with:
- **Testability** - Mock any layer independently
- **Maintainability** - Business logic isolated in entities
- **Scalability** - Add new use cases without touching existing code
- **Flexibility** - Swap implementations without changing use cases

Perfect for large teams and complex domains!
:::

## Generated Container Structure

**What gets generated:**

```
src/
‚îú‚îÄ‚îÄ container.gen.ts          # Main container
‚îú‚îÄ‚îÄ container.gen.d.ts        # Type declarations
‚îî‚îÄ‚îÄ modules/
    ‚îú‚îÄ‚îÄ userModule.module.ts  # User use cases, repos, presenters
    ‚îî‚îÄ‚îÄ todoModule.module.ts  # Todo use cases, repos, presenters
```

**All wired automatically** with proper:
‚Ä¢ Dependency injection  
‚Ä¢ Lifecycle management  
‚Ä¢ Cross-module dependencies  
‚Ä¢ Type-safe resolution

---

**Want to try it?** Check out the `/examples/clean-architecture` directory in the IoC Arise repository!
