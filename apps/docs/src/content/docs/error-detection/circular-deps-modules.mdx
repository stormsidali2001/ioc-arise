---
title: Circular Dependencies (Modules) Example
description: Demonstrates how IoC Arise detects and handles circular dependencies between modules
sidebar:
  order: 8
---

import { FileTree, Card, CardGrid, Badge, Tabs, TabItem } from '@astrojs/starlight/components';

<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0 2rem 0;">
  <Badge text="Module-Level Detection" variant="caution" />
  <Badge text="Compile-Time" variant="success" />
  <Badge text="Cross-Module" variant="tip" />
</div>

:::danger[‚ö†Ô∏è Module Circular Dependencies]
When modules depend on each other in a cycle, it creates an unsolvable dependency problem:
- **ModuleA** depends on **ModuleB**
- **ModuleB** depends on **ModuleA**
- **Impossible to load either module!**

IoC Arise **detects module-level circular dependencies** at compile-time before they become runtime disasters!
:::

## Project Structure

<FileTree>
- circular-deps-modules/
  - interfaces/
    - IServiceA.ts
    - IServiceB.ts
  - services/
    - ServiceA.ts
    - ServiceB.ts
  - ioc.config.json
  - README.md
</FileTree>

## The Circular Dependency

<Tabs>
  <TabItem label="Module Configuration">

```json
{
  "sourceDir": ".",
  "outputPath": "container.gen.ts",
  "interface": "I*.ts",
  "modules": {
    "ModuleA": [
      "services/ServiceA.ts",
      "interfaces/IServiceA.ts"
    ],
    "ModuleB": [
      "services/ServiceB.ts", 
      "interfaces/IServiceB.ts"
    ]
  }
}
```

**The Problem:** ModuleA and ModuleB are configured as separate modules, but they depend on each other!

  </TabItem>
  <TabItem label="Interfaces">

```typescript
// interfaces/IServiceA.ts
export interface IServiceA {
  doSomething(): string;
}

// interfaces/IServiceB.ts
export interface IServiceB {
  doSomething(): string;
}
```

  </TabItem>
  <TabItem label="ServiceA (ModuleA)">

**ServiceA depends on ServiceB** (from ModuleB):

```typescript
// services/ServiceA.ts
import { IServiceB } from '../interfaces/IServiceB';

export class ServiceA implements IServiceA {
  constructor(private serviceB: IServiceB) {}
  //                          ^^^^^^^^
  //                     Needs ModuleB!
  
  doSomething(): string {
    return 'A: ' + this.serviceB.doSomething();
  }
}
```

  </TabItem>
  <TabItem label="ServiceB (ModuleB)">

**ServiceB depends on ServiceA** (from ModuleA):

```typescript
// services/ServiceB.ts
import { IServiceA } from '../interfaces/IServiceA';

export class ServiceB implements IServiceB {
  constructor(private serviceA: IServiceA) {}
  //                          ^^^^^^^^
  //                     Needs ModuleA!
  
  doSomething(): string {
    return 'B: ' + this.serviceA.doSomething();
  }
}
```

**The Cycle:** ModuleA ‚Üí ModuleB ‚Üí ModuleA (impossible to load!)

  </TabItem>
</Tabs>

## IoC Arise Detection

:::tip[üîç Automatic Module-Level Detection]
When you run `npx @notjustcoders/ioc-arise`, the CLI analyzes cross-module dependencies and catches this immediately:
:::

```bash
‚ùå Error: Circular dependency detected between modules.

Module dependency chain:
  ModuleA ‚Üí ModuleB ‚Üí ModuleA

Detailed circular dependency:
  ServiceA (ModuleA) ‚Üí IServiceB (ServiceB in ModuleB) ‚Üí IServiceA (ServiceA in ModuleA)

Modules involved in circular dependencies:
  - ModuleA: services/ServiceA.ts, interfaces/IServiceA.ts
  - ModuleB: services/ServiceB.ts, interfaces/IServiceB.ts

```

**Why this matters:**
- ‚úÖ **Caught at compile-time** - not at runtime when customers are using your app
- ‚úÖ **Clear error message** - shows exact module dependency chain
- ‚úÖ **File locations** - know exactly which modules are involved
- ‚úÖ **Prevents deployment** - won't generate container with broken module dependencies

## Key Takeaways

<CardGrid>
  <Card title="üîç Module-Level Detection" icon="magnifier">
    IoC Arise detects circular dependencies **between modules**, not just classes.
  </Card>
  <Card title="‚ö° Compile-Time Safety" icon="rocket">
    Catches module cycles before deployment. No runtime surprises!
  </Card>
  <Card title="üìä Clear Error Messages" icon="document">
    Shows exact module dependency chain with file locations.
  </Card>
  <Card title="üõ°Ô∏è Type Safety" icon="seti:typescript">
    Full TypeScript support with proper type checking across module boundaries.
  </Card>
  <Card title="‚úÖ Best Practices" icon="approve-check">
    Circular dependencies often indicate design issues - caught early before deployment!
  </Card>
</CardGrid>

:::caution[üí° Architectural Consideration]
Circular dependencies between modules indicate architectural issues that should be resolved through refactoring. IoC Arise helps you identify these problems early in development.
:::