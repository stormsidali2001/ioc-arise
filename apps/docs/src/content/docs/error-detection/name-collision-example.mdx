---
title: Name Collision Example
description: Demonstrates how IoC Arise handles classes with identical names across different modules
sidebar:
  order: 5
---

import { FileTree, Card, CardGrid, Badge, Tabs, TabItem } from '@astrojs/starlight/components';

<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0 2rem 0;">
  <Badge text="Auto-Resolution" variant="success" />
  <Badge text="Directory Prefixing" variant="tip" />
  <Badge text="Zero Configuration" variant="note" />
</div>

:::tip[üéØ Automatic Name Resolution]
IoC Arise automatically handles classes with **identical names** across different directories using directory-based prefixing. You'll learn how the container resolves naming conflicts while maintaining clean separation of concerns across different domains.
:::

## Project Structure

<FileTree>
- name-collision-example/
  - user/
    - CreateItemUseCase.ts
    - DeleteItemUseCase.ts
    - GetItemUseCase.ts
    - ListItemsUseCase.ts
    - UpdateItemUseCase.ts
    - UserController.ts
    - UserRepository.ts
  - product/
    - CreateItemUseCase.ts
    - DeleteItemUseCase.ts
    - GetItemUseCase.ts
    - ListItemsUseCase.ts
    - UpdateItemUseCase.ts
    - ProductController.ts
    - ProductRepository.ts
  - order/
    - CreateItemUseCase.ts
    - DeleteItemUseCase.ts
    - GetItemUseCase.ts
    - ListItemsUseCase.ts
    - UpdateItemUseCase.ts
    - OrderController.ts
    - OrderRepository.ts
  - container.gen.ts
  - ioc.config.json
  - README.md
</FileTree>

## The Problem

Multiple classes have identical names across different domains:
- Three `CreateItemUseCase` classes (user, product, order)
- Three `DeleteItemUseCase` classes (user, product, order)
- Three `GetItemUseCase` classes (user, product, order)
- Three `ListItemsUseCase` classes (user, product, order)
- Three `UpdateItemUseCase` classes (user, product, order)

## IoC Arise's Solution

:::note[‚ú® Automatic Resolution]
IoC Arise automatically resolves name collisions using **directory-based prefixing** - zero configuration needed!
:::

<CardGrid>
  <Card title="üìÅ Directory Prefix" icon="folder">
    Classes get prefixed with their directory name:
    ‚Ä¢ `user/CreateItemUseCase.ts` ‚Üí `UserCreateItemUseCase`
    ‚Ä¢ `product/CreateItemUseCase.ts` ‚Üí `ProductCreateItemUseCase`
    ‚Ä¢ `order/CreateItemUseCase.ts` ‚Üí `OrderCreateItemUseCase`
  </Card>
  <Card title="üîó Unique Aliases" icon="puzzle">
    Generated imports use unique aliases automatically. No manual configuration!
  </Card>
  <Card title="üìä Predictable Naming" icon="document">
    Easy to understand based on directory structure. Follows your project organization!
  </Card>
</CardGrid>

## Domain Implementations

<Tabs>
  <TabItem label="User Domain">

**User Domain** - manages user items:

```typescript
// user/CreateItemUseCase.ts
export class CreateItemUseCase {
  constructor(private userRepository: IUserRepository) {}

  async execute(itemData: { name: string; description: string }): Promise<void> {
    console.log(`Creating user item: ${itemData.name}`);
    await this.userRepository.saveUserItem(itemData);
  }
}
```

**Generated Name:** `UserCreateItemUseCase`

  </TabItem>
  <TabItem label="Product Domain">

**Product Domain** - manages products:

```typescript
// product/CreateItemUseCase.ts
export class CreateItemUseCase {
  constructor(private productRepository: IProductRepository) {}

  async execute(itemData: { name: string; price: number; category: string }): Promise<void> {
    console.log(`Creating product item: ${itemData.name} - $${itemData.price}`);
    await this.productRepository.saveProduct(itemData);
  }
}
```

**Generated Name:** `ProductCreateItemUseCase`

  </TabItem>
  <TabItem label="Order Domain">

**Order Domain** - manages order items:

```typescript
// order/CreateItemUseCase.ts
export class CreateItemUseCase {
  constructor(private orderRepository: IOrderRepository) {}

  async execute(itemData: { name: string; quantity: number; unitPrice: number }): Promise<void> {
    console.log(`Creating order item: ${itemData.name}`);
    await this.orderRepository.saveOrderItem(itemData);
  }
}
```

**Generated Name:** `OrderCreateItemUseCase`

  </TabItem>
  <TabItem label="Generated Imports">

**How IoC Arise handles it:**

```typescript
// container.gen.ts (auto-generated)
import { CreateItemUseCase as UserCreateItemUseCase } from './user/CreateItemUseCase';
import { CreateItemUseCase as ProductCreateItemUseCase } from './product/CreateItemUseCase';
import { CreateItemUseCase as OrderCreateItemUseCase } from './order/CreateItemUseCase';

// All registered with unique names!
container.register('UserCreateItemUseCase', { ... });
container.register('ProductCreateItemUseCase', { ... });
container.register('OrderCreateItemUseCase', { ... });
```

**Zero manual configuration needed!**

  </TabItem>
</Tabs>

## Usage Examples

<Tabs>
  <TabItem label="Type-Safe Resolution">

**Resolve with full IntelliSense:**

```typescript
import { container } from './container.gen';

// ‚úÖ All services have unique, prefixed names
const userCreateUseCase = container.resolve('UserCreateItemUseCase');
const productCreateUseCase = container.resolve('ProductCreateItemUseCase');
const orderCreateUseCase = container.resolve('OrderCreateItemUseCase');

// ‚úÖ Repositories and controllers are also prefixed
const userRepo = container.resolve('UserRepository');
const productRepo = container.resolve('ProductRepository');
const orderRepo = container.resolve('OrderRepository');
```

**Full autocomplete and type safety!**

  </TabItem>
  <TabItem label="Complete Workflow">

**Use all domains together:**

```typescript
import { container } from './container.gen';

const userCreateUseCase = container.resolve('UserCreateItemUseCase');
const productCreateUseCase = container.resolve('ProductCreateItemUseCase');
const orderCreateUseCase = container.resolve('OrderCreateItemUseCase');

// Each service works with its own domain data structure
await userCreateUseCase.execute({
  name: 'User Profile',
  description: 'User profile information'
});

await productCreateUseCase.execute({
  name: 'Laptop',
  price: 999.99,
  category: 'Electronics'
});

await orderCreateUseCase.execute({
  name: 'Order Item',
  quantity: 2,
  unitPrice: 49.99
});

// List items from each domain
const userListUseCase = container.resolve('UserListItemsUseCase');
const productListUseCase = container.resolve('ProductListItemsUseCase');
const orderListUseCase = container.resolve('OrderListItemsUseCase');

const userItems = await userListUseCase.execute();
const productItems = await productListUseCase.execute();
const orderItems = await orderListUseCase.execute();

console.log('User items:', userItems);
console.log('Product items:', productItems);
console.log('Order items:', orderItems);
```

  </TabItem>
</Tabs>

## Configuration

:::note[‚öôÔ∏è Minimal Configuration]
No special configuration needed - name collision resolution works automatically!
:::

```json
{
  "sourceDir": ".",
  "outputPath": "container.gen.ts",
  "interface": "I*.ts"
}
```

**What happens automatically:**
‚Ä¢ Scans all directories for classes  
‚Ä¢ Detects name collisions  
‚Ä¢ Applies directory-based prefixing  
‚Ä¢ Generates unique service names

## Name Resolution Examples

| Original File Path | Generated Service Name |
|-------------------|------------------------|
| `user/CreateItemUseCase.ts` | `UserCreateItemUseCase` |
| `product/CreateItemUseCase.ts` | `ProductCreateItemUseCase` |
| `order/CreateItemUseCase.ts` | `OrderCreateItemUseCase` |
| `user/UserController.ts` | `UserController` (no collision) |
| `product/ProductController.ts` | `ProductController` (no collision) |
| `order/OrderController.ts` | `OrderController` (no collision) |

**Note:** Only classes with collisions get prefixed. Unique names stay as-is!

## Key Takeaways

<CardGrid>
  <Card title="‚ú® Automatic Resolution" icon="magic">
    IoC Arise automatically detects and resolves name collisions - zero configuration!
  </Card>
  <Card title="üìÅ Directory-Based" icon="folder">
    Predictable naming based on directory structure. Easy to understand!
  </Card>
  <Card title="üõ°Ô∏è Type Safety" icon="seti:typescript">
    Full TypeScript support with proper type inference for all prefixed names.
  </Card>
  <Card title="üîó Clean Separation" icon="puzzle">
    Each domain maintains its own classes with identical names - no conflicts!
  </Card>
  <Card title="üìà Scalable" icon="rocket">
    Easy to add new domains without worrying about name conflicts.
  </Card>
  <Card title="‚úÖ Maintainable" icon="approve-check">
    Clear naming convention based on directory structure. Self-documenting!
  </Card>
</CardGrid>

:::tip[üöÄ Perfect for Large Applications]
IoC Arise intelligently handles naming conflicts, making it perfect for large applications with multiple domains that naturally have similar operations and naming patterns!
:::