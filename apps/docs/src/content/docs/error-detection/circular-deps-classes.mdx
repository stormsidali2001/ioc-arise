---
title: Circular Dependencies (Classes)
description: Demonstrates how IoC Arise detects and handles circular dependencies between classes
sidebar:
  order: 7
---

import { FileTree, Card, CardGrid, Badge, Tabs, TabItem } from '@astrojs/starlight/components';

<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0 2rem 0;">
  <Badge text="Error Detection" variant="caution" />
  <Badge text="Compile-Time" variant="success" />
  <Badge text="Best Practices" variant="tip" />
</div>

:::danger[‚ö†Ô∏è Critical Architecture Issue]
Circular dependencies are a common anti-pattern that can lead to:
- **Infinite loops** during instantiation
- **Stack overflow** errors at runtime
- **Difficult to maintain** code with tight coupling
- **Impossible to test** components in isolation

IoC Arise **detects these at compile-time** before they become runtime disasters!
:::

## The Problem

When two classes depend on each other, it creates an unsolvable dependency cycle:

```mermaid
graph LR
    A[ClassA] -->|depends on| B[ClassB]
    B -->|depends on| A
    style A fill:#ff6b6b
    style B fill:#ff6b6b
```

The class structure shows the circular dependency:

```mermaid
classDiagram
    class IClassA {
        <<interface>>
    }
    class ClassA {
    }
    class IClassB {
        <<interface>>
    }
    class ClassB {
    }
    
    IClassA <|.. ClassA : implements
    IClassB <|.. ClassB : implements
    ClassA --> IClassB : depends on
    ClassB --> IClassA : depends on
```

**The Cycle:** `ClassA` ‚Üí `IClassB` (resolves to `ClassB`) ‚Üí `IClassA` (resolves to `ClassA`) ‚Üí **impossible to instantiate!**

## Project Structure

<FileTree>
- circular-deps-classes/
  - interfaces/
    - IClassA.ts
    - IClassB.ts
  - services/
    - ClassA.ts
    - ClassB.ts
  - ioc.config.json
  - README.md
</FileTree>

## The Circular Dependency

<Tabs>
  <TabItem label="‚ùå ClassA (depends on B)">

```typescript
import { IClassB } from '../interfaces/IClassB';

export class ClassA implements IClassA {
  constructor(private classB: IClassB) {}
  //                          ^^^^^^^^
  //                     ClassA needs ClassB
  
  methodA(): string {
    return 'ClassA calling: ' + this.classB.methodB();
  }
}
```

  </TabItem>
  <TabItem label="‚ùå ClassB (depends on A)">

```typescript
import { IClassA } from '../interfaces/IClassA';

export class ClassB implements IClassB {
  constructor(private classA: IClassA) {}
  //                          ^^^^^^^^
  //                     ClassB needs ClassA
  
  methodB(): string {
    return 'ClassB calling: ' + this.classA.methodA();
  }
}
```

**The Problem:** ClassA can't be created without ClassB ‚Ä¢ ClassB can't be created without ClassA ‚Ä¢ **Impossible to instantiate either!**

  </TabItem>
  <TabItem label="Interfaces">

```typescript
export interface IClassA {
  methodA(): string;
}

export interface IClassB {
  methodB(): string;
}
```

  </TabItem>
</Tabs>

## IoC Arise Detection

:::tip[üîç Automatic Detection]
When you run `npx @notjustcoders/ioc-arise`, the CLI analyzes your entire dependency graph and catches this immediately:
:::

```bash
‚ùå Error: Circular dependency detected in the dependency graph.

Circular dependency chain:
  ClassA ‚Üí IClassB (ClassB) ‚Üí IClassA (ClassA)

Classes involved:
  - ClassA (/path/to/services/ClassA.ts)
  - ClassB (/path/to/services/ClassB.ts)

‚ö†Ô∏è  Fix: Refactor your code to break the circular dependency.
   Consider using events, callbacks, or dependency inversion.
```

**Why this matters:**
- ‚úÖ **Caught at compile-time** - not at runtime when customers are using your app
- ‚úÖ **Clear error message** - shows exact dependency chain
- ‚úÖ **File locations** - know exactly which files to fix
- ‚úÖ **Prevents deployment** - won't generate container with broken dependencies

## How to Fix Circular Dependencies

<CardGrid>
  <Card title="1Ô∏è‚É£ Extract Common Logic" icon="star">
    Create a third service/class that both can depend on without circular reference.
  </Card>
  <Card title="2Ô∏è‚É£ Use Events/Callbacks" icon="forward">
    Replace direct dependency with event-driven communication or callback pattern.
  </Card>
  <Card title="3Ô∏è‚É£ Dependency Inversion" icon="puzzle">
    Introduce an abstraction layer (interface) to break the direct coupling.
  </Card>
  <Card title="4Ô∏è‚É£ Lazy Resolution" icon="seti:config">
    Use lazy initialization or factory pattern to defer instantiation.
  </Card>
</CardGrid>

### Example Fix: Extract Common Service

<Tabs>
  <TabItem label="‚úÖ Before (Circular)">

```typescript
// ‚ùå ClassA ‚Üí ClassB ‚Üí ClassA (circular!)
class ClassA {
  constructor(private classB: IClassB) {}
}

class ClassB {
  constructor(private classA: IClassA) {}
}
```

  </TabItem>
  <TabItem label="‚úÖ After (Fixed)">

```typescript
// ‚úÖ Both depend on SharedService (no cycle!)
class SharedService {
  doSomething(): string {
    return 'shared logic';
  }
}

class ClassA {
  constructor(private shared: SharedService) {}
}

class ClassB {
  constructor(private shared: SharedService) {}
}
```

**Dependency Graph:**
```
ClassA ‚Üí SharedService
ClassB ‚Üí SharedService
(No circular dependency!)
```

  </TabItem>
</Tabs>
