---
title: Lifecycle Scopes Example
description: Demonstrates how to use singleton and transient scopes in IoC Arise
sidebar:
  order: 3
---

import { FileTree, Card, CardGrid, Badge, Tabs, TabItem } from '@astrojs/starlight/components';

<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0 2rem 0;">
  <Badge text="Lifecycle Management" variant="tip" />
  <Badge text="Singleton vs Transient" variant="success" />
  <Badge text="Performance" variant="note" />
</div>

:::tip[üéØ What You'll Learn]
Master **lifecycle scopes** to control how your services are instantiated:
- **Singleton Scope** - One shared instance across the entire application
- **Transient Scope** - New instance every time it's requested
- **Performance Implications** - When to use each scope
- **JSDoc Annotations** - Simple comments control the behavior
:::

## Project Structure

<FileTree>
- scope-example/
  - services/
    - SingletonService.ts  # Default scope (singleton)
    - TransientService.ts  # Explicitly transient
    - ScopedService.ts     # Explicitly singleton
    - ILogger.ts           # Interface for logging
  - container.gen.ts         # Generated container
  - demo.ts                  # Demonstration of scopes
  - ioc.config.json          # IoC configuration
  - README.md                # This file
</FileTree>

## Understanding Scopes

<CardGrid>
  <Card title="üîÑ Singleton (Default)" icon="star">
    **One instance shared everywhere**
    
    ‚Ä¢ Perfect for stateless services  
    ‚Ä¢ Better performance (created once)  
    ‚Ä¢ Use for: Repositories, configs, caches  
    ‚Ä¢ No annotation needed (default)
  </Card>
  
  <Card title="‚ö° Transient" icon="rocket">
    **New instance every time**
    
    ‚Ä¢ Perfect for stateful services  
    ‚Ä¢ Isolated state per request  
    ‚Ä¢ Use for: Request handlers, commands  
    ‚Ä¢ Requires `@scope transient` annotation
  </Card>
</CardGrid>

## Service Examples

<Tabs>
  <TabItem label="Singleton (Default)">

**No annotation needed** - singleton is the default:

```typescript
// ‚úÖ No @scope annotation = Singleton by default
export class SingletonService {
  private static instanceCounter = 0;
  private instanceId: number;

  constructor(private logger: ILogger) {
    SingletonService.instanceCounter++;
    this.instanceId = SingletonService.instanceCounter;
    this.logger.log(`SingletonService instance ${this.instanceId} created`);
  }

  getServiceId(): string {
    return `SingletonService (instance ${this.instanceId})`;
  }
}
```

**Result:** Only creates ONE instance, reused everywhere.

  </TabItem>
  <TabItem label="Transient">

**Add `@scope transient` JSDoc comment:**

```typescript
/**
 * @scope transient
 */
export class TransientService {
  private static instanceCounter = 0;
  private instanceId: number;

  constructor(private logger: ILogger) {
    TransientService.instanceCounter++;
    this.instanceId = TransientService.instanceCounter;
    this.logger.log(`TransientService instance ${this.instanceId} created`);
  }

  getServiceId(): string {
    return `TransientService (instance ${this.instanceId})`;
  }
}
```

**Result:** Creates a NEW instance every time you resolve it.

  </TabItem>
  <TabItem label="Explicit Singleton">

**Explicitly specify singleton** (same as default):

```typescript
/**
 * @scope singleton
 */
export class ScopedService {
  private static instanceCounter = 0;
  private instanceId: number;

  constructor(private logger: ILogger) {
    ScopedService.instanceCounter++;
    this.instanceId = ScopedService.instanceCounter;
    this.logger.log(`ScopedService instance ${this.instanceId} created`);
  }

  getServiceId(): string {
    return `ScopedService (instance ${this.instanceId})`;
  }
}
```

**Best Practice:** Be explicit for clarity!

  </TabItem>
</Tabs>

## Generated Container

:::tip[‚ú® Auto-Generated Lifecycles]
The CLI detects `@scope` annotations and generates the correct lifecycle configuration automatically!
:::

```typescript
// container.gen.ts
import { Container, Lifecycle } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './container.gen.d';
import { SingletonService } from './services/SingletonService';
import { TransientService } from './services/TransientService';
import { ScopedService } from './services/ScopedService';
import { Logger } from './services/Logger';

export const container = new Container<ContainerRegistry>();

// ‚úÖ Logger: Singleton (default)
container.register('ILogger', {
  useClass: Logger,
  lifecycle: Lifecycle.Singleton,
});

// ‚úÖ SingletonService: Singleton (default, no annotation)
container.register(SingletonService, {
  useClass: SingletonService,
  dependencies: ['ILogger'],
  lifecycle: Lifecycle.Singleton,
});

// ‚úÖ TransientService: Transient (from @scope transient)
container.register(TransientService, {
  useClass: TransientService,
  dependencies: ['ILogger'],
  lifecycle: Lifecycle.Transient,
});

// ‚úÖ ScopedService: Singleton (from @scope singleton)
container.register(ScopedService, {
  useClass: ScopedService,
  dependencies: ['ILogger'],
  lifecycle: Lifecycle.Singleton,
});
```

## Usage Examples

<Tabs>
  <TabItem label="Singleton Behavior">

**Singletons return the same instance every time:**

```typescript
import { container } from './container.gen';

// Resolve twice
const singleton1 = container.resolve(SingletonService);
const singleton2 = container.resolve(SingletonService);

// ‚úÖ Same instance!
console.log(singleton1 === singleton2); // true

// ‚úÖ Same instance ID!
console.log(singleton1.getServiceId()); // SingletonService (instance 1)
console.log(singleton2.getServiceId()); // SingletonService (instance 1)
```

**Output:**
```
SingletonService instance 1 created
true
SingletonService (instance 1)
SingletonService (instance 1)
```

Only one instance created!

  </TabItem>
  <TabItem label="Transient Behavior">

**Transients create a new instance every time:**

```typescript
import { container } from './container.gen';

// Resolve twice
const transient1 = container.resolve(TransientService);
const transient2 = container.resolve(TransientService);

// ‚ùå Different instances!
console.log(transient1 === transient2); // false

// ‚ùå Different instance IDs!
console.log(transient1.getServiceId()); // TransientService (instance 1)
console.log(transient2.getServiceId()); // TransientService (instance 2)
```

**Output:**
```
TransientService instance 1 created
TransientService instance 2 created
false
TransientService (instance 1)
TransientService (instance 2)
```

Two instances created!

  </TabItem>
  <TabItem label="Complete Comparison">

**Side-by-side comparison:**

```typescript
import { container } from './container.gen';

// Singletons
const s1 = container.resolve(SingletonService);
const s2 = container.resolve(SingletonService);
console.log(`Singleton: ${s1 === s2}`); // true ‚úÖ

// Transients
const t1 = container.resolve(TransientService);
const t2 = container.resolve(TransientService);
console.log(`Transient: ${t1 === t2}`); // false ‚ùå

// Explicit Singleton
const scoped1 = container.resolve(ScopedService);
const scoped2 = container.resolve(ScopedService);
console.log(`Scoped: ${scoped1 === scoped2}`); // true ‚úÖ
```

**Output:**
```
Singleton: true
Transient: false
Scoped: true
```

Clear difference in behavior!

  </TabItem>
</Tabs>

## Configuration

:::note[‚öôÔ∏è Simple Config]
No special configuration needed - the CLI detects `@scope` annotations automatically!
:::

```json
{
  "sourceDir": ".",
  "outputPath": "container.gen.ts",
  "interface": "I*.ts"
}
```

The CLI will:
‚Ä¢ Scan all TypeScript files  
‚Ä¢ Detect `@scope` JSDoc tags  
‚Ä¢ Generate correct lifecycle configurations

## When to Use Each Scope

<CardGrid>
  <Card title="üîÑ Use Singleton For:" icon="star">
    **Stateless or shared-state services**
    
    ‚Ä¢ Database connections  
    ‚Ä¢ Configuration services  
    ‚Ä¢ Logging services  
    ‚Ä¢ Cache managers  
    ‚Ä¢ Repository implementations
  </Card>
  
  <Card title="‚ö° Use Transient For:" icon="rocket">
    **Stateful or isolated services**
    
    ‚Ä¢ HTTP request handlers  
    ‚Ä¢ Command processors  
    ‚Ä¢ Per-request loggers  
    ‚Ä¢ Event processors  
    ‚Ä¢ Short-lived workers
  </Card>
</CardGrid>

## Key Takeaways

<CardGrid>
  <Card title="üéØ Simple Annotations" icon="pencil">
    Just add `@scope transient` in a JSDoc comment. Default is singleton.
  </Card>
  <Card title="‚ö° Performance" icon="rocket">
    Singletons create once, transients create on-demand. Choose wisely!
  </Card>
  <Card title="üõ°Ô∏è Type Safety" icon="seti:typescript">
    Full IntelliSense regardless of scope. No runtime surprises.
  </Card>
  <Card title="üß™ Testability" icon="approve-check">
    Mock any service easily, regardless of its lifecycle scope.
  </Card>
</CardGrid>

:::tip[üöÄ Best Practice]
**Be explicit with `@scope` annotations** even for singletons. It makes your code more readable and intentions clear to other developers!
:::