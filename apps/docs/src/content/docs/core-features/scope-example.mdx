---
title: Scope Example
description: Demonstrates how to use singleton and transient scopes in IoC Arise
sidebar:
  order: 3
---

{/* Hook Section */}
This example demonstrates how to use **singleton** and **transient** scopes in IoC Arise. You'll learn how to control the lifecycle of your services and understand the difference between shared and new instances.

import { FileTree } from '@astrojs/starlight/components';

## Project Structure

<FileTree>
- scope-example/
  - services/
    - SingletonService.ts  # Default scope (singleton)
    - TransientService.ts  # Explicitly transient
    - ScopedService.ts     # Explicitly singleton
    - ILogger.ts           # Interface for logging
  - container.gen.ts         # Generated container
  - demo.ts                  # Demonstration of scopes
  - ioc.config.json          # IoC configuration
  - README.md                # This file
</FileTree>

## Key Concepts

1. **Singleton Scope** (default)
   - One instance is created and shared across the entire application
   - Perfect for services that are stateless or manage shared state
   - All classes are singletons unless specified otherwise

2. **Transient Scope**
   - A new instance is created every time the service is requested
   - Ideal for services that are stateful and need to be isolated
   - Use the `@scope transient` JSDoc tag to mark a class as transient

{/* Body Section with Open Loops */}

## Service Definitions

### SingletonService (Default)

No special annotation is needed for singleton scope:

```typescript
import { ILogger } from './ILogger';

// This service is a singleton by default
export class SingletonService {
  private static instanceCounter = 0;
  private instanceId: number;

  constructor(private logger: ILogger) {
    SingletonService.instanceCounter++;
    this.instanceId = SingletonService.instanceCounter;
    this.logger.log(`SingletonService instance ${this.instanceId} created`);
  }

  getServiceId(): string {
    return `SingletonService (instance ${this.instanceId})`;
  }
}
```

### TransientService

Use the `@scope transient` JSDoc tag:

```typescript
import { ILogger } from './ILogger';

/**
 * @scope transient
 */
export class TransientService {
  private static instanceCounter = 0;
  private instanceId: number;

  constructor(private logger: ILogger) {
    TransientService.instanceCounter++;
    this.instanceId = TransientService.instanceCounter;
    this.logger.log(`TransientService instance ${this.instanceId} created`);
  }

  getServiceId(): string {
    return `TransientService (instance ${this.instanceId})`;
  }
}
```

### ScopedService (Explicit Singleton)

You can also explicitly mark a class as a singleton:

```typescript
import { ILogger } from './ILogger';

/**
 * @scope singleton
 */
export class ScopedService {
  private static instanceCounter = 0;
  private instanceId: number;

  constructor(private logger: ILogger) {
    ScopedService.instanceCounter++;
    this.instanceId = ScopedService.instanceCounter;
    this.logger.log(`ScopedService instance ${this.instanceId} created`);
  }

  getServiceId(): string {
    return `ScopedService (instance ${this.instanceId})`;
  }
}
```

## Generated Container

The CLI generates a container using `@notjustcoders/di-container` with proper lifecycle settings:

```typescript
// container.gen.ts
import { Container, Lifecycle } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './container.gen.d';
import { SingletonService } from './services/SingletonService';
import { TransientService } from './services/TransientService';
import { ScopedService } from './services/ScopedService';
import { Logger } from './services/Logger';

export const container = new Container<ContainerRegistry>();

container.register('ILogger', {
  useClass: Logger,
  lifecycle: Lifecycle.Singleton, // Singletons share one instance
});

container.register(SingletonService, {
  useClass: SingletonService,
  dependencies: ['ILogger'],
  lifecycle: Lifecycle.Singleton,
});

container.register(TransientService, {
  useClass: TransientService,
  dependencies: ['ILogger'],
  lifecycle: Lifecycle.Transient, // Transients create new instances
});

container.register(ScopedService, {
  useClass: ScopedService,
  dependencies: ['ILogger'],
  lifecycle: Lifecycle.Singleton,
});
```

## Usage with Container

### Resolving Services

```typescript
import { container } from './container.gen';

// Resolve singleton services (same instance every time)
const singleton1 = container.resolve(SingletonService);
const singleton2 = container.resolve(SingletonService);

// Resolve transient services (new instance every time)
const transient1 = container.resolve(TransientService);
const transient2 = container.resolve(TransientService);

console.log(singleton1.getServiceId()); // SingletonService (instance 1)
console.log(singleton2.getServiceId()); // SingletonService (instance 1) - Same!

console.log(transient1.getServiceId()); // TransientService (instance 1)
console.log(transient2.getServiceId()); // TransientService (instance 2) - Different!

// Verify instance identity
console.log(singleton1 === singleton2); // true - Same instance!
console.log(transient1 === transient2); // false - Different instances!
```

## Example Workflow

```typescript
import { container } from './container.gen';

// 1. Resolve singleton services multiple times
const s1 = container.resolve(SingletonService);
const s2 = container.resolve(SingletonService);
console.log(`s1 === s2: ${s1 === s2}`); // true - Same instance

// 2. Resolve transient services multiple times
const t1 = container.resolve(TransientService);
const t2 = container.resolve(TransientService);
console.log(`t1 === t2: ${t1 === t2}`); // false - Different instances

// 3. Resolve explicitly scoped singleton
const scoped1 = container.resolve(ScopedService);
const scoped2 = container.resolve(ScopedService);
console.log(`scoped1 === scoped2: ${scoped1 === scoped2}`); // true

// 4. Verify instance IDs
console.log(s1.getServiceId()); // SingletonService (instance 1)
console.log(s2.getServiceId()); // SingletonService (instance 1) - Same!

console.log(t1.getServiceId()); // TransientService (instance 1)
console.log(t2.getServiceId()); // TransientService (instance 2) - Different!

console.log(scoped1.getServiceId()); // ScopedService (instance 1)
console.log(scoped2.getServiceId()); // ScopedService (instance 1) - Same!
```

## IoC Configuration

```json
{
  "source": ".",
  "output": "container.gen.ts",
  "interface": "I[A-Z].*",
  "exclude": [
    "**/*.test.ts",
    "**/*.spec.ts"
  ],
  "verbose": true
}
```

This configuration:
- Scans the current directory for classes
- Automatically detects `@scope` JSDoc tags
- Generates a container with proper singleton and transient providers

{/* Conclusion Section */}

## Benefits of Scoped Services

1. **Lifecycle Control**: Precisely manage the lifecycle of your services
2. **State Management**: Use singletons for shared state and transients for isolated state
3. **Performance**: Singletons are created once, reducing overhead
4. **Flexibility**: Mix and match scopes to fit your application's needs
5. **Testability**: Easy to mock services regardless of their scope
6. **Clean Code**: No complex configuration needed - just a simple JSDoc tag

This example shows how IoC Arise's scope management provides powerful control over service lifecycles with minimal effort, enabling you to build robust and efficient applications!