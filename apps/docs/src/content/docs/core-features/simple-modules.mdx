---
title: Simple Modules Example
description: Demonstrates IoC Arise's module system with cross-module dependencies
sidebar:
  order: 2
---

import { FileTree } from '@astrojs/starlight/components';

{/* Hook Section */}

This example demonstrates IoC Arise's **module system** with two separate modules that have cross-module dependencies. You'll learn how to organize your code into logical modules while maintaining type-safe dependency injection across module boundaries.

## Project Structure

<FileTree>
- simple-modules/
  - user/
    - User.ts User entity
    - IUserRepository.ts User repository interface
    - UserRepository.ts User repository implementation
    - IUserService.ts User service interface
    - UserService.ts User service implementation
  - todo/
    - Todo.ts Todo entity
    - ITodoRepository.ts Todo repository interface
    - TodoRepository.ts Todo repository implementation
    - ITodoService.ts Todo service interface
    - TodoService.ts Todo service implementation (cross-module dependency)
  - container.gen.ts Main container aggregating modules
  - demo.ts Demonstration of module interaction
  - ioc.config.json IoC configuration with module definitions
  - README.md This file
</FileTree>

## Key Features

### 1. Module Organization

Each module encapsulates related functionality:

**UserModule:**

- `User` entity with user data
- `IUserRepository` & `UserRepository` for data access
- `IUserService` & `UserService` for business logic

**TodoModule:**

- `Todo` entity with todo data
- `ITodoRepository` & `TodoRepository` for data access
- `ITodoService` & `TodoService` for business logic

### 2. Cross-Module Dependencies

The TodoService demonstrates cross-module dependency by depending on UserRepository:

```typescript
export class TodoService implements ITodoService {
  constructor(
    private todoRepository: ITodoRepository, // Same module (TodoModule)
    private userRepository: IUserRepository, // Different module (UserModule)!
  ) {}

  async createTodo(title: string, userId: string): Promise<Todo> {
    // Validate user exists using cross-module dependency
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error(`User with ID ${userId} not found`);
    }
    // Create todo logic...
  }
}
```

### 3. Automatic Dependency Resolution

IoC Arise automatically:

- Discovers dependencies across modules
- Creates proper module instantiation order
- Wires everything together in a unified container

{/* Body Section with Open Loops */}

## Generated Container Structure

After running `npx @notjustcoders/ioc-arise generate`, you'll get:

```
src/
├── container.gen.ts          # Main container
├── container.gen.d.ts        # Type declarations
└── modules/
    ├── userModule.module.ts  # User module registrations
    └── todoModule.module.ts  # Todo module registrations
```

### Main Container

```typescript
// container.gen.ts
import { Container } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './container.gen.d';
import { userModule } from './modules/userModule.module';
import { todoModule } from './modules/todoModule.module';

export const container = new Container<ContainerRegistry>();

container.registerModule(userModule);
container.registerModule(todoModule);
```

### Module Files

```typescript
// modules/userModule.module.ts
import { ContainerModule, Lifecycle } from '@notjustcoders/di-container';
import { UserService } from '../user/UserService';
import { UserRepository } from '../user/UserRepository';

export const userModule = new ContainerModule()
  .register('IUserService', { 
    useClass: UserService, 
    dependencies: ['IUserRepository'], 
    lifecycle: Lifecycle.Singleton 
  })
  .register('IUserRepository', { 
    useClass: UserRepository, 
    lifecycle: Lifecycle.Singleton 
  });
```

## Usage with Container

### Type-Safe Resolution

```typescript
import { container } from "./container.gen";

// Resolve services with full type safety
const userService = container.resolve('IUserService');
const userRepository = container.resolve('IUserRepository');

const todoService = container.resolve('ITodoService');
const todoRepository = container.resolve('ITodoRepository');

// Create a user
const user = await userService.createUser("John Doe", "john@example.com");

// Create a todo for the user (cross-module dependency in action!)
const todo = await todoService.createTodo("Learn IoC Arise", user.id);

// Get all users and their todos
const users = await userService.getAllUsers();
const userTodos = await todoService.getTodosByUser(user.id);

console.log("Users:", users);
console.log("Todos for user:", userTodos);
```

## Example Workflow

```typescript
import { container } from "./container.gen";

// Get services
const userService = container.resolve('IUserService');
const todoService = container.resolve('ITodoService');

// 1. Create users
const alice = await userService.createUser("Alice", "alice@example.com");
const bob = await userService.createUser("Bob", "bob@example.com");

// 2. Create todos for users (cross-module validation!)
const aliceTodo = await todoService.createTodo("Buy groceries", alice.id);
const bobTodo = await todoService.createTodo("Walk the dog", bob.id);

// 3. Get todos by user
const aliceTodos = await todoService.getTodosByUser(alice.id);
console.log("Alice's todos:", aliceTodos);

// 4. Update todo status
const updated = await todoService.updateTodo(aliceTodo.id, undefined, true);
console.log("Updated todo:", updated);

// 5. Try to create todo for non-existent user (will throw error)
try {
  await todoService.createTodo("Invalid", "invalid-user-id");
} catch (error) {
  console.log("Expected error:", error.message);
  // Output: "User with ID invalid-user-id not found"
}
```

## Entity Definitions

### User Entity

```typescript
export class User {
  constructor(
    public id: string,
    public name: string,
    public email: string,
  ) {}
}
```

### Todo Entity

```typescript
export class Todo {
  constructor(
    public id: string,
    public title: string,
    public userId: string,
    public completed: boolean = false,
  ) {}
}
```

## Service Interfaces

### IUserService

```typescript
export interface IUserService {
  getAllUsers(): Promise<User[]>;
  getUserById(id: string): Promise<User | undefined>;
  createUser(name: string, email: string): Promise<User>;
  updateUser(
    id: string,
    name?: string,
    email?: string,
  ): Promise<User | undefined>;
  deleteUser(id: string): Promise<boolean>;
}
```

### ITodoService

```typescript
export interface ITodoService {
  getAllTodos(): Promise<Todo[]>;
  getTodoById(id: string): Promise<Todo | undefined>;
  getTodosByUser(userId: string): Promise<Todo[]>;
  createTodo(title: string, userId: string): Promise<Todo>;
  updateTodo(
    id: string,
    title?: string,
    completed?: boolean,
  ): Promise<Todo | undefined>;
  deleteTodo(id: string): Promise<boolean>;
}
```

## Cross-Module Dependencies Example

The Todo module depends on the User module through the `IUserRepository` interface:

```typescript
import { Todo } from "./Todo";
import { ITodoService } from "./ITodoService";
import { ITodoRepository } from "./ITodoRepository";
import { IUserRepository } from "../user/IUserRepository";

/**
 * @scope singleton
 */
export class TodoService implements ITodoService {
  constructor(
    private todoRepository: ITodoRepository,
    private userRepository: IUserRepository,
  ) {}

  async getTodosByUser(userId: string): Promise<Todo[]> {
    // Verify user exists before getting todos
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error(`User with id ${userId} not found`);
    }
    return this.todoRepository.findByUserId(userId);
  }

  async createTodo(title: string, userId: string): Promise<Todo> {
    // Verify user exists before creating todo
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error(`User with id ${userId} not found`);
    }
    return this.todoRepository.create(title, userId);
  }

  // ... other methods
}
```

## Post-Construction Initialization

The `onInit()` function is **exported from the generated container.gen.ts file**, not a method in your classes:

```typescript
import { onInit } from "./container.gen";

// The onInit function is called automatically when inject() is first used
// You can modify it in the generated container.gen.ts file for custom initialization
```

For services that need cross-module dependencies setup:

```typescript
export class ApplicationCoordinator {
  private userService!: IUserService;
  private todoService!: ITodoService;

  initializeCrossModuleDependencies() {
    this.userService = inject("userModule.IUserService");
    this.todoService = inject("todoModule.ITodoService");
    console.log(
      "ApplicationCoordinator initialized with cross-module dependencies",
    );
  }

  async setupUserWithTodos(name: string, email: string, todoTitles: string[]) {
    // Create user using UserModule service
    const user = await this.userService.createUser(name, email);

    // Create todos using TodoModule service (with cross-module dependency)
    const todos = [];
    for (const title of todoTitles) {
      const todo = await this.todoService.createTodo(title, user.id);
      todos.push(todo);
    }

    console.log(`Created user ${user.name} with ${todos.length} todos`);
    return { user, todos };
  }

  async getUserStats(userId: string) {
    const user = await this.userService.getUser(userId);
    const userTodos = await this.todoService.getTodosByUser(userId);

    return {
      user: user?.name || "Unknown",
      totalTodos: userTodos.length,
      completedTodos: userTodos.filter((t) => t.completed).length,
    };
  }
}
```

## IoC Configuration

The `ioc.config.json` defines modules and their patterns:

```json
{
  "source": ".",
  "output": "container.gen.ts",
  "modules": {
    "UserModule": ["user/**/*"],
    "TodoModule": ["todo/**/*"]
  }
}
```

This configuration:

- Groups files in `user/` directory into `UserModule`
- Groups files in `todo/` directory into `TodoModule`
- Automatically resolves cross-module dependencies
- Generates separate module containers with proper dependency injection order

{/* Conclusion Section */}

## Benefits of Modular Architecture

1. **Modular Organization**: Keep related code together in logical modules
2. **Cross-Module Dependencies**: Services can safely depend on other modules
3. **Type Safety**: Full TypeScript support across module boundaries
4. **Testability**: Easy to mock entire modules or individual services
5. **Scalability**: Add new modules without affecting existing ones
6. **Clean Architecture**: Clear separation of concerns between domains
7. **Dependency Validation**: Automatic validation of cross-module dependencies

This example shows how IoC Arise's module system enables clean separation of concerns while maintaining the ability to share functionality across domains, making it perfect for scalable applications!

