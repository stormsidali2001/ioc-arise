---
title: Simple Modules Example
description: Demonstrates IoC Arise's module system with cross-module dependencies
sidebar:
  order: 2
---

import { FileTree, Card, CardGrid, Badge, Tabs, TabItem } from '@astrojs/starlight/components';

<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0 2rem 0;">
  <Badge text="Modular Architecture" variant="tip" />
  <Badge text="Cross-Module DI" variant="success" />
  <Badge text="Auto-Generated" variant="note" />
</div>

:::tip[üéØ What You'll Learn]
This example demonstrates IoC Arise's **powerful module system** for organizing large codebases:
- **Logical Module Separation** - Group related functionality together
- **Cross-Module Dependencies** - Services can depend on other modules seamlessly
- **Auto-Generated Module Files** - CLI creates separate module files automatically
- **Type-Safe Resolution** - Full IntelliSense across module boundaries
:::

## Project Structure

<FileTree>
- simple-modules/
  - user/
    - User.ts User entity
    - IUserRepository.ts User repository interface
    - UserRepository.ts User repository implementation
    - IUserService.ts User service interface
    - UserService.ts User service implementation
  - todo/
    - Todo.ts Todo entity
    - ITodoRepository.ts Todo repository interface
    - TodoRepository.ts Todo repository implementation
    - ITodoService.ts Todo service interface
    - TodoService.ts Todo service implementation (cross-module dependency)
  - container.gen.ts Main container aggregating modules
  - demo.ts Demonstration of module interaction
  - ioc.config.json IoC configuration with module definitions
  - README.md This file
</FileTree>

## Module Organization

<CardGrid>
  <Card title="üë• User Module" icon="user">
    **User Domain** - Encapsulates all user-related functionality:
    
    ‚Ä¢ `User` entity with validation  
    ‚Ä¢ `IUserRepository` data access interface  
    ‚Ä¢ `UserRepository` in-memory implementation  
    ‚Ä¢ `IUserService` business logic interface  
    ‚Ä¢ `UserService` with CRUD operations
  </Card>
  
  <Card title="‚úÖ Todo Module" icon="document">
    **Todo Domain** - Manages todo items with user ownership:
    
    ‚Ä¢ `Todo` entity with user reference  
    ‚Ä¢ `ITodoRepository` data access interface  
    ‚Ä¢ `TodoRepository` in-memory implementation  
    ‚Ä¢ `ITodoService` business logic interface  
    ‚Ä¢ `TodoService` **depends on UserModule!**
  </Card>
</CardGrid>

## Cross-Module Dependencies

:::note[üîó The Power of Modules]
TodoService demonstrates **cross-module dependency** by depending on UserRepository from a different module. IoC Arise handles this automatically!
:::

The TodoService depends on both its own module AND the User module:

```typescript
export class TodoService implements ITodoService {
  constructor(
    private todoRepository: ITodoRepository, // Same module (TodoModule)
    private userRepository: IUserRepository, // Different module (UserModule)!
  ) {}

  async createTodo(title: string, userId: string): Promise<Todo> {
    // Validate user exists using cross-module dependency
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error(`User with ID ${userId} not found`);
    }
    // Create todo logic...
  }
}
```

## What IoC Arise Does Automatically

<CardGrid>
  <Card title="üîç Discovery" icon="magnifier">
    Analyzes all files and discovers dependencies **across module boundaries**
  </Card>
  <Card title="üìä Ordering" icon="list-format">
    Creates proper module instantiation order to avoid circular dependencies
  </Card>
  <Card title="üîó Wiring" icon="puzzle">
    Generates all registration code with correct dependency arrays
  </Card>
  <Card title="‚úÖ Validation" icon="approve-check">
    Detects issues at compile-time before they become runtime errors
  </Card>
</CardGrid>

## Generated Container Structure

:::tip[‚ú® One Command, Modular Output]
Run `npx @notjustcoders/ioc-arise` and get a complete modular setup:
:::

<Tabs>
  <TabItem label="File Structure">

```
src/
‚îú‚îÄ‚îÄ container.gen.ts          # Main container
‚îú‚îÄ‚îÄ container.gen.d.ts        # Type declarations
‚îî‚îÄ‚îÄ modules/
    ‚îú‚îÄ‚îÄ userModule.module.ts  # User module
    ‚îî‚îÄ‚îÄ todoModule.module.ts  # Todo module
```

**Benefits:**
‚Ä¢ Clean separation of concerns  
‚Ä¢ Easy to navigate and understand  
‚Ä¢ Follows standard module patterns  
‚Ä¢ Scales to hundreds of modules

  </TabItem>
  <TabItem label="Main Container">

```typescript
// container.gen.ts
import { Container } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './container.gen.d';
import { userModule } from './modules/userModule.module';
import { todoModule } from './modules/todoModule.module';

export const container = new Container<ContainerRegistry>();

// ‚úÖ Modules registered in correct order
container.registerModule(userModule);
container.registerModule(todoModule);
```

The container aggregates all modules into one unified DI system!

  </TabItem>
  <TabItem label="User Module">

```typescript
// modules/userModule.module.ts
import { ContainerModule, Lifecycle } from '@notjustcoders/di-container';
import { UserService } from '../user/UserService';
import { UserRepository } from '../user/UserRepository';

export const userModule = new ContainerModule()
  .register('IUserService', { 
    useClass: UserService, 
    dependencies: ['IUserRepository'], 
    lifecycle: Lifecycle.Singleton 
  })
  .register('IUserRepository', { 
    useClass: UserRepository, 
    lifecycle: Lifecycle.Singleton 
  });
```

Each module is self-contained and independently testable!

  </TabItem>
  <TabItem label="Todo Module">

```typescript
// modules/todoModule.module.ts
import { ContainerModule, Lifecycle } from '@notjustcoders/di-container';
import { TodoService } from '../todo/TodoService';
import { TodoRepository } from '../todo/TodoRepository';

export const todoModule = new ContainerModule()
  .register('ITodoService', { 
    useClass: TodoService, 
    // ‚úÖ Cross-module dependency detected!
    dependencies: ['ITodoRepository', 'IUserRepository'], 
    lifecycle: Lifecycle.Singleton 
  })
  .register('ITodoRepository', { 
    useClass: TodoRepository, 
    lifecycle: Lifecycle.Singleton 
  });
```

TodoModule depends on UserModule - **handled automatically!**

  </TabItem>
</Tabs>

## Usage Example

:::tip[üéØ Type-Safe Cross-Module Resolution]
Services from different modules work together seamlessly with full type safety!
:::

<Tabs>
  <TabItem label="Basic Usage">

```typescript
import { container } from "./container.gen";

// ‚úÖ Resolve services from User Module
const userService = container.resolve('IUserService');
//    ^? IUserService - Full autocomplete!

// ‚úÖ Resolve services from Todo Module  
const todoService = container.resolve('ITodoService');
//    ^? ITodoService - Full autocomplete!

// Create a user
const user = await userService.createUser(
  "John Doe", 
  "john@example.com"
);

// Create a todo (uses cross-module dependency!)
const todo = await todoService.createTodo(
  "Learn IoC Arise", 
  user.id
);
```

  </TabItem>
  <TabItem label="Complete Workflow">

```typescript
import { container } from "./container.gen";

const userService = container.resolve('IUserService');
const todoService = container.resolve('ITodoService');

// Step 1: Create multiple users
const alice = await userService.createUser("Alice", "alice@example.com");
const bob = await userService.createUser("Bob", "bob@example.com");

// Step 2: Create todos for users (cross-module!)
const aliceTodo1 = await todoService.createTodo("Buy groceries", alice.id);
const aliceTodo2 = await todoService.createTodo("Call dentist", alice.id);
const bobTodo = await todoService.createTodo("Finish project", bob.id);

// Step 3: Get todos by user (demonstrates module interaction)
const aliceTodos = await todoService.getTodosByUser(alice.id);
const bobTodos = await todoService.getTodosByUser(bob.id);

console.log(`Alice has ${aliceTodos.length} todos`);
console.log(`Bob has ${bobTodos.length} todos`);
```

**Output:**
```
Alice has 2 todos
Bob has 1 todos
```

  </TabItem>
  <TabItem label="Error Handling">

```typescript
import { container } from "./container.gen";

const todoService = container.resolve('ITodoService');

// ‚ùå Try to create todo for non-existent user
try {
  await todoService.createTodo(
    "Invalid todo", 
    "non-existent-user-id"
  );
} catch (error) {
  console.error(error.message);
  // Output: "User with ID non-existent-user-id not found"
}
```

**The Magic:**  
TodoService validates users via `IUserRepository` (from UserModule) **before** creating todos. This is **cross-module validation** at its finest!

  </TabItem>
</Tabs>

## Domain Models

<Tabs>
  <TabItem label="Entities">

**User Entity:**
```typescript
export class User {
  constructor(
    public id: string,
    public name: string,
    public email: string,
  ) {}
}
```

**Todo Entity (with user reference):**
```typescript
export class Todo {
  constructor(
    public id: string,
    public title: string,
    public userId: string,  // ‚úÖ Links to User
    public completed: boolean = false,
  ) {}
}
```

  </TabItem>
  <TabItem label="User Interface">

**IUserService** - User operations:

```typescript
export interface IUserService {
  getAllUsers(): Promise<User[]>;
  getUserById(id: string): Promise<User | undefined>;
  createUser(name: string, email: string): Promise<User>;
  updateUser(
    id: string,
    name?: string,
    email?: string,
  ): Promise<User | undefined>;
  deleteUser(id: string): Promise<boolean>;
}
```

Standard CRUD operations for users.

  </TabItem>
  <TabItem label="Todo Interface">

**ITodoService** - Todo operations:

```typescript
export interface ITodoService {
  getAllTodos(): Promise<Todo[]>;
  getTodoById(id: string): Promise<Todo | undefined>;
  getTodosByUser(userId: string): Promise<Todo[]>;  // ‚úÖ Cross-module query
  createTodo(title: string, userId: string): Promise<Todo>;
  updateTodo(
    id: string,
    title?: string,
    completed?: boolean,
  ): Promise<Todo | undefined>;
  deleteTodo(id: string): Promise<boolean>;
}
```

Note: `getTodosByUser()` and `createTodo()` require user validation from UserModule!

  </TabItem>
</Tabs>

## Configuration

:::note[‚öôÔ∏è Simple Module Configuration]
Tell IoC Arise which files belong to which module using glob patterns:
:::

```json
{
  "sourceDir": ".",
  "outputPath": "container.gen.ts",
  "modules": {
    "UserModule": ["user/**/*"],
    "TodoModule": ["todo/**/*"]
  }
}
```

**What this does:**
‚Ä¢ Groups all `user/` files ‚Üí `UserModule`  
‚Ä¢ Groups all `todo/` files ‚Üí `TodoModule`  
‚Ä¢ Resolves cross-module dependencies automatically  
‚Ä¢ Generates separate module files with proper order

## Key Takeaways

<CardGrid>
  <Card title="üì¶ Modular Organization" icon="puzzle">
    Keep related code together in logical, self-contained modules. Perfect for domain-driven design!
  </Card>
  <Card title="üîó Cross-Module DI" icon="star">
    Services can safely depend on other modules. IoC Arise handles the wiring automatically.
  </Card>
  <Card title="üõ°Ô∏è Type Safety" icon="seti:typescript">
    Full IntelliSense and compile-time checking across all module boundaries.
  </Card>
  <Card title="üß™ Easy Testing" icon="approve-check">
    Mock entire modules or individual services. Modules are independently testable.
  </Card>
  <Card title="üìà Scalability" icon="rocket">
    Add new modules without touching existing code. Grows with your application.
  </Card>
  <Card title="‚úÖ Auto-Validation" icon="warning">
    Circular dependencies and missing services caught at compile-time.
  </Card>
</CardGrid>

:::tip[üöÄ Production Ready]
IoC Arise's module system enables **clean separation of concerns** while maintaining the ability to share functionality across domains. Perfect for:
- **Microservices** - Each module can become a service
- **Monorepos** - Share modules across packages
- **Large Teams** - Work on modules independently
- **Clean Architecture** - Enforce domain boundaries
:::

