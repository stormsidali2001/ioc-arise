---
title: Use Cases Example
description: Demonstrates how IoC Arise handles classes that don't implement interfaces but are used as dependencies
sidebar:
  order: 4
---

{/* Hook Section */}
This example demonstrates how IoC Arise handles classes that **do not implement interfaces** but are used as dependencies (like use cases in clean architecture). You'll learn how the container automatically includes these classes to support proper dependency injection.

import { FileTree } from '@astrojs/starlight/components';

## Project Structure

<FileTree>
- use-cases-example/
  - ioc.config.json
  - container.gen.ts
  - repositories/
    - IUserRepository.ts
    - UserRepository.ts
  - services/
    - IEmailService.ts
    - EmailService.ts
    - IApplicationService.ts
    - ApplicationService.ts
  - use-cases/
    - CreateUserUseCase.ts
    - GetUserUseCase.ts
    - UserController.ts
</FileTree>

## Key Points

1. **Interface-based classes**: Repository and service classes implement interfaces (`IUserRepository`, `IEmailService`, `IApplicationService`)
2. **Non-interface classes**: Use case classes (`CreateUserUseCase`, `GetUserUseCase`, `UserController`) do NOT implement interfaces
3. **Dependency inclusion**: IoC Arise includes non-interface classes because they are used as dependencies by other classes
4. **Automatic detection**: The tool automatically detects and includes all classes that participate in dependency injection

{/* Body Section with Open Loops */}

## Generated Container Structure

The generated container has a `coreModule` structure:

```typescript
export const container = {
  coreModule: {
    // Interface-based access (recommended)
    IUserRepository: UserRepository,
    IEmailService: EmailService, 
    IApplicationService: ApplicationService,
    
    // Direct class access
    CreateUserUseCase: CreateUserUseCase,
    GetUserUseCase: GetUserUseCase,
    UserController: UserController
  }
};
```

## Usage Examples

### Using Direct Container Access

```typescript
import { container } from './container.gen';

// Access services via interfaces
const userRepo = container.coreModule.IUserRepository;
const emailService = container.coreModule.IEmailService;
const appService = container.coreModule.IApplicationService;

// Access use cases directly
const createUserUseCase = container.coreModule.CreateUserUseCase;
const getUserUseCase = container.coreModule.GetUserUseCase;
const userController = container.coreModule.UserController;

// Run the application
await appService.runUserOperations();
```

### Using the inject() Function

```typescript
import { inject } from './container.gen';

// Inject services by interface
const userRepo = inject('coreModule.IUserRepository');
const emailService = inject('coreModule.IEmailService');
const appService = inject('coreModule.IApplicationService');

// Inject use cases by class name
const createUserUseCase = inject('coreModule.CreateUserUseCase');
const userController = inject('coreModule.UserController');

// Example usage
await userController.createUser('Alice Johnson', 'alice@example.com');
await userController.getUser('1');
```

## Service Definitions

### User Entity and Repository Interface

```typescript
export interface IUserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<void>;
  findAll(): Promise<User[]>;
}

export interface User {
  id: string;
  name: string;
  email: string;
}
```

### Email Service Interface

```typescript
export interface IEmailService {
  sendEmail(to: string, subject: string, body: string): Promise<void>;
  sendWelcomeEmail(userEmail: string, userName: string): Promise<void>;
}
```

## Use Case WITHOUT Interface

This is a key feature - IoC Arise can include classes that don't implement interfaces but are used as dependencies:

```typescript
import { IUserRepository } from '../repositories/IUserRepository';
import { IEmailService } from '../services/IEmailService';

// This is a use case class that does NOT implement an interface
// It should be included in the container because it's used as a dependency

export class CreateUserUseCase {
  constructor(
    private userRepository: IUserRepository,
    private emailService: IEmailService
  ) {}

  async execute(name: string, email: string): Promise<void> {
    const user = {
      id: Date.now().toString(),
      name,
      email
    };

    await this.userRepository.save(user);
    await this.emailService.sendWelcomeEmail(user.email, user.name);
    
    console.log(`User created: ${user.name} (${user.email})`);
  }
}
```

## Another Use Case WITHOUT Interface

```typescript
import { IUserRepository } from '../repositories/IUserRepository';

export class GetUserUseCase {
  constructor(private userRepository: IUserRepository) {}

  async execute(userId: string): Promise<void> {
    const user = await this.userRepository.findById(userId);
    if (user) {
      console.log(`Found user: ${user.name} (${user.email})`);
    } else {
      console.log(`User with ID ${userId} not found`);
    }
  }
}
```

## Controller Using Use Cases

```typescript
import { CreateUserUseCase } from './CreateUserUseCase';
import { GetUserUseCase } from './GetUserUseCase';

// This controller uses use cases as dependencies
// It does NOT implement an interface but should be included because it's used as a dependency
export class UserController {
  constructor(
    private createUserUseCase: CreateUserUseCase,
    private getUserUseCase: GetUserUseCase
  ) {}

  async createUser(name: string, email: string): Promise<void> {
    console.log('UserController: Creating user...');
    await this.createUserUseCase.execute(name, email);
  }

  async getUser(userId: string): Promise<void> {
    console.log('UserController: Getting user...');
    await this.getUserUseCase.execute(userId);
  }
}
```

## Generated Container

```typescript
// container.gen.ts
import { Container, Lifecycle } from '@notjustcoders/di-container';
import type { ContainerRegistry } from './container.gen.d';
import { UserRepository } from './repositories/UserRepository';
import { UserService } from './services/UserService';
import { CreateUserUseCase } from './use-cases/CreateUserUseCase';
import { GetUserUseCase } from './use-cases/GetUserUseCase';
import { UserController } from './services/UserController';

export const container = new Container<ContainerRegistry>();

container.register('IUserRepository', {
  useClass: UserRepository,
  lifecycle: Lifecycle.Singleton,
});

container.register('IUserService', {
  useClass: UserService,
  dependencies: ['IUserRepository'],
  lifecycle: Lifecycle.Singleton,
});

container.register(CreateUserUseCase, {
  useClass: CreateUserUseCase,
  dependencies: ['IUserService'],
  lifecycle: Lifecycle.Singleton,
});

container.register(GetUserUseCase, {
  useClass: GetUserUseCase,
  dependencies: ['IUserService'],
  lifecycle: Lifecycle.Singleton,
});

container.register(UserController, {
  useClass: UserController,
  dependencies: [CreateUserUseCase, GetUserUseCase],
  lifecycle: Lifecycle.Singleton,
});
```

## Usage

```typescript
import { container } from './container.gen';

// Resolve by interface (string token)
const userRepo = container.resolve('IUserRepository');
const userService = container.resolve('IUserService');

// Resolve by class constructor (use cases & controllers)
const createUserUseCase = container.resolve(CreateUserUseCase);
const getUserUseCase = container.resolve(GetUserUseCase);
const userController = container.resolve(UserController);

// Use the services
await userController.createUser('John Doe', 'john@example.com');
await userController.getUser('user-123');
```

## Configuration

```json
{
  "sourceDir": ".",
  "outputPath": "container.gen.ts",
  "interface": "I*.ts",
  "exclude": [
    "node_modules",
    "dist",
    "**/*.test.ts",
    "**/*.spec.ts"
  ]
}
```

## Running the Example

1. Generate the container:
   ```bash
   npx @notjustcoders/ioc-arise generate
   ```

2. The generated container includes all classes that are either:
   - Implementing interfaces (repositories and services), OR
   - Used as dependencies by other classes (use cases and controllers)

3. Use `container.resolve()` to retrieve dependencies with full type safety

4. The container handles all dependency injection automatically with proper lifecycle management

{/* Conclusion Section */}

## Benefits of Non-Interface Class Support

1. **Clean Architecture Support**: Perfect for use cases that don't need interfaces
2. **Automatic Detection**: IoC Arise automatically includes classes used as dependencies
3. **Type Safety**: Full TypeScript support for both interface-based and direct class injection
4. **Flexibility**: No forced interface implementation for simple classes
5. **Dependency Validation**: Ensures all participating classes are properly registered

This example shows how IoC Arise intelligently handles both interface-based and direct class dependencies, making it perfect for clean architecture patterns where use cases and controllers don't always need interface contracts!