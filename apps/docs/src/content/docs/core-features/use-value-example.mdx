---
title: Plain Object Services (useValue)
description: Register pre-created instances directly using useValue - perfect for functional programming patterns
sidebar:
  order: 6
---

import { FileTree, Card, CardGrid, Badge, Tabs, TabItem } from '@astrojs/starlight/components';

<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0 2rem 0;">
  <Badge text="Functional Programming" variant="tip" />
  <Badge text="Plain Objects" variant="success" />
  <Badge text="useValue" variant="note" />
</div>

The `useValue` pattern allows you to register pre-created instances directly in the container, without requiring classes or factory functions.

## Project Structure

<FileTree>
- use-value-example/
  - services/
    - IUserService.ts
    - userService.ts        # Plain object
    - IConfigService.ts
    - configService.ts      # Plain object
  - container.gen.ts
  - demo.ts
</FileTree>

## When to Use

<CardGrid>
  <Card title="‚úÖ Plain Objects" icon="seti:typescript">
    Functional programming style - no classes
  </Card>
  
  <Card title="‚öôÔ∏è Configuration" icon="gear">
    App configuration objects
  </Card>
  
  <Card title="üîå Third-Party" icon="plug">
    Pre-created instances from external libraries
  </Card>
  
  <Card title="üß™ Testing" icon="flask">
    Easy to mock for testing
  </Card>
</CardGrid>

## Example

<Tabs>
  <TabItem label="Interface">

```typescript
// services/IUserService.ts
export interface IUserService {
  getUser(id: string): string;
  createUser(data: { name: string; email: string }): { 
    id: string; 
    name: string; 
    email: string 
  };
}
```

  </TabItem>
  <TabItem label="Plain Object">

```typescript
// services/userService.ts
import { IUserService } from './IUserService';

/**
 * @value
 */
export const userService: IUserService = {
  getUser: (id: string) => `User-${id}`,
  createUser: (data: { name: string; email: string }) => ({
    id: `user-${Date.now()}`,
    name: data.name,
    email: data.email,
  }),
};
```

  </TabItem>
  <TabItem label="Generated">

```typescript
container.register('IUserService', {
  useValue: userService,
  lifecycle: Lifecycle.Singleton,
});
```

  </TabItem>
</Tabs>

## Detection

Values are automatically detected if they:
- Are marked with `@value` JSDoc annotation (default behavior)
- Match the `valuePattern` regex if configured in `ioc.config.json`
- Implement a known interface (backward compatibility fallback)

```typescript
// ‚úÖ Detected - marked with @value
/**
 * @value
 */
export const userService: IUserService = { ... };

// ‚úÖ Detected - matches valuePattern if configured (e.g., "Service$")
export const configService: IConfigService = { ... };

// ‚ùå Not detected - no @value annotation and doesn't match pattern
export const helper = { ... };
```

## Lifecycle

:::note[üîÑ Always Singleton]
`useValue` services are always singletons because they're pre-created instances.
:::

## Comparison

| Feature | useClass | useFactory | useValue |
|---------|----------|------------|----------|
| **Creates instance?** | Yes (via `new`) | Yes (via function) | No (uses existing) |
| **Dependencies?** | Yes | Yes | No |
| **Lifecycle Transient?** | Yes | Yes | No (always singleton) |
| **Pattern** | OOP | Functional | Functional |

## Usage

```typescript
import { container } from './container.gen';

const userService = container.resolve('IUserService');
const user = userService.getUser('123');
```

## Configuration

You can configure value detection patterns in `ioc.config.json`:

```json
{
  "valuePattern": "Service$"
}
```

This will match any value name ending with "Service" (case-insensitive), in addition to values with `@value` annotations.

## Best Practices

1. Always type plain objects with interfaces
2. Use `@value` JSDoc annotation to explicitly mark values for detection
3. Use `export const` to make objects detectable
4. Remember: `useValue` objects can't have dependencies (pre-created)
5. Perfect for configuration objects that don't need DI
6. Configure `valuePattern` in large projects to limit detection scope
